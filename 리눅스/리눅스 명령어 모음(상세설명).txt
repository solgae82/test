adduser 
사용자를 새로 등록한다. 

문법 
■ adduser 

설명 
이것은 슈퍼 유저만이 사용할 수 있다. 

명령을 입력하면 로그온 이름 등을 차례로 물어오며, 그에 따라서 알맞게 입력해 나가면 된다. 

■ Enter login name for new account (^C to quit): blade 
■ Editing information for new user [blade] 
■ Full name: Park Chan Wook ,,사용자 전체 이름을 입력 
■ GD [100]: ,,정해주는 값을 그냥 사용한다. 

그외에도 홈 디렉토리에 사용하는 셸 등을 계속 물어오는데, 

대괄호 속에 내정된 것을 그냥 사용하고자 한다면 엔터키만 누르면 된다. 

패스워드 등을 입력하고 나면 지금까지 입력된 정보를 보여주고, 

몇 가지 생성 작업을 화면으로 보여준 후 작업을 종료한다. 




at 
프로그램을 지금이 아닌 나중에 실행하도록 예약한다. 

문법 
■ at -q [-m][-f 파일명] 큐(queue) 시간 
■ at -r 작업번호 
■ at -l 

옵션 
-q 큐 : 대소문자 알파벳으로 큐를 지정한다. 순서적으로 빠른 알파벳이 지정된 큐 일수록 CPU 시간 점유 우선권이 낮다. 
-r 작업번호 : 큐에서 작업 번호가 지시하는 작업을 지운다. 슈퍼유저가 아니라면 자신의 작업만을 지울 수 있다. 
-l : 현재 계획된 작업들의 목록을 보여준다. 슈퍼 유저라면 모든 작업들의 계획목록을 보여준다. 
-m : 작업이 완결되면 사용자에게 메일을 보낸다. 
-f 파일명 : 표준 입력이 아닌 지시된 파일에서 작업을 읽어온다. 

설명 
명령은 기본적으로 표준 입력 장치를 통해서 받으며, 

^D로 입력을 종료한다. 리다이렉션을 사용하여 다른 파일의 내용을 사용할 수 있다. 

/etc/at.allow 파일이 있다면 이 파일에 명단이 있는 사용자만이 at 명령을 사용할 수 있다. 

/etc/at.allow 파일이 없다면 /etc/at.deny 파일을 찾는다. 

이 파일에 목록이 있는 사용자는 at 명령을 사용할 수 없다. 

두 파일 모두 찾지 못한다면 오로지 슈퍼 유저만이 at 명령을 사용할 수 있다. 

그리고 /etc/at.deny 파일이 비어 있다면 모든 사용자가 at 명령을 사용할 수 있다. 

시간을 지정할 때 상당히 다양한 방법을 사용할 수 있다. hhmm 혹은 hh:mm 형태도 가능하며, noon, midnight이나 오후 4시를 의미하는 teatime이라고도 할 수 있다. 오전 오후를 쉽게 구분하려면 am pm 문자를 추가해도 된다. 이미 지나간 시간이라면 다음 날 그 시간에 수행될 것이다. 정확한 날짜를 지정하려면 mmddyy 혹은 mm/dd/yy 아니면 dd.mm.yy 형태 중 선택하라. 

현재부터 얼마의 시간이 경과한 후에 수행할지를 지정하려면 기호를 사용하라. 이 기호뒤에 숫자를 명시하고, 다시 뒤에 그 숫자의 단위가 무엇인지 지정하면 된다. 

사용예 
■ at 8am work 
work에 수록된 작업 사항들을 오전 8시에 수행하도록 한다. 

■ at noon work ,,정오에 work에 수록된 작업을 수행한다. 
■ at -f work 14:40 tomorrow 
내일 오후2시 40분에 work 파일에 수록된 작업을 수행한다. 




banner 
인수로 주어진 문자열을 큰 글씨로 만들어서 출력한다. 

문법 
■ banner [ -w [숫자] ] 문자열 

옵션 
-w : 옵션 지정만 하면 80 칼럼으로 폭을 바꾼다. 지정하지 않으면 132 칼럼으로 내정되어 있다. -w 옵션 뒤에 숫자를 지정하면 원하는 폭으로 조정할 수 있다. 

설명 
출력은 표준 출력으로 내정되어 있다. 글자는 열 배 정도 확대된다. 글자는 에스터리스크(*)를 조합하여 만든다. 

사용예 
■ banner "hello world" 
■ banner linux | lqr ,,디폴트 프린터에 확대한 글자를 출력한다. 




bash 
이것은 리눅스의 Boume 셸이다. sh를 사용하면 sh가 bash를 호출하여 실행한다. bash를 직접 사용하지 말고 sh를 사용하도록 하라. 

문법 
■ sh [ 옵션 ][ 파일 ] 

설명 
sh의 설명을 참조하라. 




biff 
전자우편의 수신을 즉시 알려주는 동작을 가능하게 할 것인지 그렇지 않은 지의 여부를 보여주거나 결정한다. 

문법 
■ biff [ y 혹은 n] 

설명 
유닉스 셸은 사용중이라도 주기적으로 전자우편의 수신 여부를 점검한다. 만일 사용자가 전자우편이 도착하는 즉시 알고자 한다면 biff를 사용하여 그것을 지시할 수 있다. 또는 언제라도 그 기능을 해제할 수도 있다. biff는 인수없이 사용되면 현재 어떤 상태로 되어 있는지 보여준다. 기능 설정과 해제 여부는 y 혹은 n 인수를 주어서 결정한다. 

사용예 
■ $ biff 
■ is n ,,전자우편 수신 즉시 통고 기능은 설정되어 있지 않음 
■ $ biff y ,,기능설정 
■ $ biff 
■ is y 




cal 
서기 원년부터 9999년까지의 달력을 볼 수 있다. 

문법 
■ cal [-jy] [ [ 달 ] 연도 ] 

옵션 
-j : 1월 1일부터 날짜수를 계산하는 julian 날짜를 표시한다. 
-y : 올해의 달력을 표시한다. 

설명 
인수를 하나만 준다면 그 숫자는 연도를 의미하는 것으로 간주된다. 두 개의 숫자를 준다면 앞의 것은 월, 그 다음은 연도를 의미하는 것이 된다. 우리의 습관과는 다른 방법을 사용한다. 아무 인수도 주어지지 않으면 이번달의 달력을 표시한다. 연도를 표기할 때는 서기를 완전히 표기해야 한다. 예를들어 97은 1997년이 아니라 서기 97년의 달력을 출력할 것이다. 

사용예 
■ $ cal 1997 
■ $ cal 4 1997 



cat 
cat은 catenate(사슬로 잇다. 연결하다)에서 이름이 유래한다. 이것은 파일의 내용을 화면에 출력하는 데 사용되기도 하며 파일을 다른 곳에 순차적인 스트림으로 보내기 위해 사용된다. 

문법 
■ cat [ -benstuvETA ] [ 파일명(들) ] 

옵션 
-b : 공백 외의 글자가 있는 모든 행의 개수를 센다. 
-e : 제어 문자를 ^ 형태로 출력하면서, 각 행의 끝에 $를 추가한다. -vE와 같다. 
-n : 각 행을 출력하면서 행 번호를 함께 첨부한다. 
-s : 중복되고 겹치는 빈 행은 하나의 빈 행으로 처리한다. 
-r : 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력한다. -vT와 같다. 
-u : 유닉스 호환성을 위해 추가된 옵션으로서 무시된다. 
-v : tab과 행바꿈 문자를 제외한 제어 문자를 ^ 형태로 출력한다. 
-E : 각 행마다 끝에 $ 문자를 출력한다. 
-T : 시로서 탭(tab) 문자를 출력한다. 
-A : -vET 옵션을 사용한 것과 같은 효과를 가진다. 

설명 
유닉스 시스템은 기본적으로 텍스트 자료들을 처리하는 것을 매우 중요시 여겼다. 많은 초기 설정 작업들이 텍스트 문서로 이루어지고, 텍스트 문서를 처리하는 수많은 명령들이 있다. cat 명령은 그러한 것들 중 기본적인 것이다. 

cat 명령은 읽어들이는 파일 이름을 지정하지 않으면, 기본 내정값으로 표준 입력 장치를 선정한다. 
■ $ cat 

이렇게 하면 키보드로부터 입력을 받고, ^d로 입력이 끝나면 다시 표준 출력 장치인 화면으로 출력한다. 

사용예 
■ $ cat document.1 ,,document.1 파일을 화면으로 출력한다. 
■ $ cat content report.first myreport 

content와 report.first 두 개의 문서가 연결된 myreport라는 파일을 생성하게 된다. 


cd 
현재 작업하는 디렉토리를 변경한다. 

문법 
■ cd [ 디렉토리 ] 

설명 
디렉토리 이름과 cd 명령 사이에 반드시 공백이 있어야 한다. 디렉토리 이름을 주지 않고 수행하면 사용자의 홈 디렉토리로 이동한다. 자신이 이동하고자 하는 디렉토리는 자신에게 실행 권한(execution permission)이 있어야 한다. 

사용예 
■ $ cd /home 
■ $ pwd 
■ /home 




chgrp 
파일의 그룹 소유권을 바꾼다. 

문법 
■ chgrp [ -cfvR ] 그룹 파일들 

옵션 
-c : 실제로 소유자가 바뀐 파일에 대해서 자세히 기술한다. 
-f : 파일의 그룹 소유권을 바꿀 수 없더라도 에러 메시지를 출력하지 않는다. 
-v : 소유권의 바뀜에 대해서 자세히 기술한다. 
-R : 디렉토리와 그 내용 파일들의 소유권을 재귀적으로 모두 바꾼다. 

설명 
파일의 소유자나 슈퍼 유저만이 파일의 그룹 소유권을 바꿀 수 있다. chgrp 명령 뒤에 원하는 옵션을 사용한 후 목적하는 그룹의 이름을 명시하고 대상 파일의 이름을 명시한다. 

사용예 
■ $ chgrp DoublePlus /usr/project/* 
이것은 /usr/project의 모든 파일들의 소유권을 DoublePlus 그룹으로 바꾼다. 



chmod 
파일의 모드를 바꾼다. 파일의 모드는 권한(permission) 을 제어한다. 

문법 
■ chmod [ -cfvR ] 모드 파일명(들) 
■ chmod [ -cfvR ] 레벨 동작 권한 파일이름(들) 

옵션 
-c : 실제로 파일의 권한이 바뀐 파일만 자세히 기술한다. 
-f : 파일의 권한이 바뀔 수 없어도 에러 메시지를 출력하지 않는다. 
-v : 변경된 권한에 대해서 자세히 기술한다. 
-R : 디렉토리와 파일들의 권한을 재귀적으로 모두 바꾼다. 

설명 
위에서 보인 문법에서 첫 번째 보인 형식에 사용되는 모드는 파일의 권한을 8진수로 표현한 값이 된다. 파일의 권한은 세 가지가 있기 때문에 각 특성을 하나의 비트로 표현하면 0부터 7까지의 수로 표현할 수 있다. 이것은 8진법 표현이 매우 적당하다. 

두 번째 형식은 어떤 사용자 레벨을 바꿀 것인가 어떻게 바꿀 것인가를 개별적으로 정하는 방법이다. 숫자를 사용하지 않고 ls 등을 사용할 때 실제로 볼 수 있는 기호 문자를 사용한다는 것과 특정 권한을 줄 것인가 뺄 것인가 지정할 수 있다는 장점이 있다. 특정한 경우 두 번째 형식이 편리하겠지만 고유한 값의 권한을 지정하는데에는 첫 번째 형식이 훨씬 편리할 것이다. 8진법을 다루는 것은 조금만 알면 너무나 쉽기 때문이다. 

사용예 
■ $ chmod 666 broadboard ,,파일을 모두가 읽고 쓸 수 있도록 한다. 
■ $ chmod 746 broad ,,파일 권한을 -rwxr--rw-로 변경한다. 
■ $ chmod o x,g-w broadboard 
파일 소유자는 실행권한을 추가하고, 그룹은 쓰기 권한을 금지한다. 

■ $ chmod u=r broad ,, 다른 사용자의 권한을 읽기로 제한한다. 
사용자의 다른 권한은 사라져 버린다. 



chown 
파일의 소유권을 다른 사람에게로 변경시킨다. 

문법 
■ chown [ -cfvR ] 사용자 파일명(들) 

옵션 
-c : 실제로 파일의 소유권이 바뀐 파일만 자세히 기술한다. 
-f : 파일의 소유권이 바뀔 수 없어도 에러 메시지를 출력하지 않는다. 
-v : 변경된 소유권에 대해서 자세히 기술한다. 
-R : 디렉토리와 파일들의 소유권을 재귀적으로 모두 바꾼다. 

설명 
파일의 소유권을 다른 사람에게로 바꾸는 것은 슈퍼 유저만이 할 수 있다. 

사용예 
■ $ chown blade /user/sisap/* 
/usr/sisap 디렉토리의 모든 파일을 blade의 것으로 바꾼다. 


clear 
clear 명령은 도스의 cls와 마찬가지로 화면을 지우는 동작을 한다. 

문법 
■ cmp [-ls][파일명][파일명2][오프셋1][오프셋2] 

옵션 
-l : 일치하지 않는 모든 바이트 값과 그 오프셋을 알 수 있다. 
-s : 비교만을 수행할 뿐 아무런 메시지도 출력하지 않는다. 

설명 
옵션없이 두 파일 이름만을 지정하면 cmp는 두 개의 파일 처음부터 순서대로 비교를 시작한다. 만일 끝까지 차이점을 발견하지 못하면 cmp는 조용히 끝난다. 

만일 중간에 다른 점을 발견한다면 더 이상의 작업은 중단하고 차이를 발견한 지점을 알려주고는 종료한다. 또한 계속해서 일치해 나가다가 두 파일 중 어느 하나가 끝나는 경우가 있을 수 있다. 다시 말해, 한 파일이 다른 파일의 앞부분에 해당하는 경우이다. 이때는 어느쪽 파일의 end of file 표시를 만나게 되었는지를 알려주고 종료한다. 

■ $ cmp document1 document2 
■ document1 document2 differ: char 128, line 13 ,,차이 발견 
오프셋을 지정하면 파일의 어느 부분부터 비교할 것인지를 정할 수 있다. -s 옵션이 왜 필요한 지를 이해하지 못할 테지만, cmp 명령이 보이지 않게 리턴값을 들려준다는 점을 알면 이해할 수 있을 것이다. cmp는 비교 후 두 파일이 일치한다고 판단하면 0을 리턴하며, 그렇지 않으면 1을 리턴한다. 셸 스크립트 상에서 비교 결과만을 원하고 화면에 메시지가 출력되는 것을 원치 않을 때에는 이러한 옵션을 사용할 수 있을 것이다. C 언어를 아는 사람이라면 금방 이해할 수 있었으리라 생각된다. 

사용예 
■ $ cmp mail.1 mail.2 13 14 



compress 
파일을 압축하거나 압축을 푼다. 

문법 
■ compress [ -cCdfv ] 파일명 
옵션 
-c : 옵션을 사용하면 압축 결과가 표준 출력으로 나가며 파일은 변함없다. 
-C : 파일을 블록으로 분화하는 것을 금지한다. 이것은 compress의 구식 버전이 파일을 읽을 수 있도록 하기 위함이다. 
-f : 수행 결과 파일과 같은 이름의 파일이 있다면 물어보지 않고 덮어쓴다. 또한 파일의 크기가 줄어들지 않더라도 파일 이름에 .Z를 추가한다. 
-v : 파일이 압축되면 압축 효율을 퍼센트로 보여준다. 

설명 
압축된 파일은 이름에 접미사 .Z가 추가된다. 압축 알고리즘에 의해 크기가 줄어드는 경우만 압축을 수행한다. -d 옵션은 역으로 압축을 풀지만 uncompress를 사용하면 옵션을 주지 않고 압축을 풀 수 있다. 압축을 푸는 경우 파일 이름 뒤에 접미사 .Z를 생략할 수도 있다. 

사용예 
■ $ compress -v roman 
■ $ compress -d noman.Z 혹은 $ compress -d roman 



cp 
: 파일을 현재의 위치나 다른 디렉토리로 복사(copy)한다. 

문법 
■ cp [ -abdfilPprsuvxR ] 파일명1 파일명2 
■ cp [ -abdfilPprsuvxR ] 파일명(들) 디렉토리 

옵션 
-a : 가능한한 원 파일의 구조와 속성을 그대로 복사한다. 
-b : 복사할 때 덮어쓰게 되는 파일은 백업을 만든다. 
-d : 심볼릭 링크는 심볼릭 링크로 복사한다. 그리고 원본 파일과의 하드 링크 관계를 유지한다. 
-f : 복사 위치에 존재하는 파일을 제거하고 복사한다. 
-i : 복사시 같은 이름의 파일이 존재한다면 덮어쓸 것인가 확인한다. 
-I : 하드 링크를 만든다. 
-P : 원본 파일의 소유자, 그룹, 권한, 시간 기록을 그대로 복사한다. 
-r : 파일과 하위 디렉토리에 포함된 파일 모두를 재귀적으로 복사한다. 
-s : 디렉토리가 아닌 파일의 심볼릭 링크를 만든다. 소스 파일의 이름은 전체 경로 이름으로 한다. 목적지 파일 이름은 전체 경로를 주지 않아도 현재 디렉토리로 간주되므로 상관없다. 
-u : 파일의 정보를 갱신한다. 
-x : 다른 파일 시스템인 하위 디렉토리는 무시한다. 
-R : 디렉토리를 재귀적(recursive)으로 복사한다. 

설명 
만일 파일명2가 이미 존재하는 파일의 이름이라면 기존에 있던 파일은 사라지고 새로운 복사본 파일로 바뀐다. 이것이 원하지 않는 결과라면 -i 옵션을 주어서 확인 작업을 거칠 수 있다. -i 옵션은 파일명2가 이미 존재하는 이름이라면 그대로 복사할 것인지 아닌지를 선택할 수 있게 물어온다. 

사용예 
■ $ cp -i blade.Z temp.Z 
■ $ cp -r * /somewhere 
당연히 -r 옵션은 파일명2가 디렉토리 이름일 때만 사용이 가능하다. 




crontab 
: 실행될 프로그램들과 스케줄의 cron 데몬을 구성한다. 

문법 
■ crontab -l [ -u 사용자 ] 
■ crontab -e [ -u 사용자 ] 
■ crontab -d [ -u 사용자 ] 

옵션 
-l : crontab 파일 목록을 보여준다. 
-e : 에디터를 사용하여 crontab 파일을 수정한다. 
-d : 사용자의 crontab 파일을 지운다. 
-u 사용자 : 특정 사용자의 crontab 파일을 다루도록 지정한다. 이 명령을 사용하려면 슈퍼 유저로 로그인해야만 한다. 

설명 
crontab 파일 내의 빈 핵과 # 문자로 시작되는 행은 무시된다. 

파일의 각 행은 M H D m d cmd 형태로 되어 있다. 필드의 에스테리스크(*)표시는 어떠한 값이든 일치하는 조건으로 가정한다는 의미이다. 
■ M 분을 의미한다.(0-59) H 시를 의미한다(0-23) 
■ D 날짜를 의미한다(1-31) m 달을 의미한다(1-12) 
■ d 요일을 의미한다(0-6) cmd 실행할 명령을 의미한다. 

cut 
: 파일에서 필드를 뽑아낸다. 필드는 필드 구분자나 문자 위치로 지정된다. 

문법 
■ cut -c문자위치 파일명(들) 
■ cut -f필드 -d필드 구분자 [ -s ] 파일명(들) 

옵션 
-c문자위치 : 잘라낼 곳의 글자 위치를 지정한다. 콤마를 사용하거나 하이픈을 사용하여 범위를 정할 수도 있으며, 이런 표현들을 혼합하여 사용할 수도 있다. 
-f필드 : 잘라낼 필드를 정한다. 지정하는 방법은 -c 옵션과 같다. 
-d필드 구분자 : 필드를 구분하는 문자를 지정한다. 디폴트는 탭 문자다. 
-s : 필드 구분자를 포함할 수 없다면 그 행은 하지 않는다. 

사용예 
■ $ cut -f1,5 -d: /etc/passwd 
■ $ cut -c1,3-7 /usr/tmp/board 


date 

: 시스템은 현재의 날짜와 시간을 유지하고 있다. date 명령을 사용하면 그러한 시간을 확인할 수 있다. 또한 날짜와 시간 정보를 변경할 수 있다. 물론 시스템의 날짜와 시간은 슈퍼 유저만이 변경할 수 있다. 

문법 
■ date [yymmddhhmm [ss] ] 
■ date 형식 

설명 
date 는 위와 같이 주어진 인수가 없다면 현재 시스템의 시간과 날짜를 출력한다. 주어지는 인지가 있다면 그에 따라서 시스템의 시간과 날짜를 변경한다. 

yy는 연도를 나타내는 두 숫자이며(99년까지), mm은 월을 나타내는 수이다. 그리고 dd는 날짜, hh는 24시간 단위로 표현되는 시간이며, mm은 분을 의미한다. 마지막 ss는 초를 의미하는 부분인데, 명시하지 않아도 상관없다. 

형식 구문을 사용한다면 날짜가 출력되는 형태를 지정할 수 있다. 여기에 사용되는 기호는 다음과 같은 것들이 있다. 

■ n 개행 t 수평탭 
■ H 시간(00-23) I 시간(01-12) 
■ k 시간(0-23) l 시간(1-12) 
■ M 분(00-59) p AM 혹은 PM 
■ r 시간(12단위, hh:mm:ss AM/PM) 
■ s 초(00-61) T 시간(24단위, hh:mm:ss) 
■ X 시간 표현(hh:mm:ss) Z 시간대(예를들어CMT) 
■ a 요일표현(Sun-Sat) A 요일명(Sunday-Saturday) 
■ b 달 표현(Jan-Dec) B 달이름(January-December) 
■ D mm/dd/yy 형태의 날짜 h %b 와 같은 것 
■ j 일년단위 날짜(001-366) m 달(01-12) 
■ y 서기의 뒷부분 숫자(00-99) Y 서기(0000-9999) 

사용예 
■ $ date 
The Oct 1 15:57:23 KST 1996 




df 
: 디스크의 여유 공간을 검사하여 보고한다. 

문법 
■ df [ -aikpvtx ] 파일시스템 

옵션 
-a : 0 블록을 가진 파일도 보고한다. 기본적으로는 무시한다. 
-i : 블록 사용 대신 incode 사용 정보를 보고한다. 
-k : 블록의 크기를 1K바이트로 계산한다. 
-p : POSIX 형태의 출력을 한다. 
-v : System V의 df와의 호환을 위한 옵션이다. 무시된다. 
-t 형태 : 특정 형태의 파일 시스템으로 검사를 제한한다. 
-x 형태 : 특정 형태의 파일 시스템 이외의 것으로 검사를 제한한다. 

설명 
이것은 바이트 크기를 사용하는 대신 블록 단위로 보고한다는 점을 유의해야 한다. 기본적으로 512바이트 크기로 한 블록을 다룬다. 



diff 
: 두 개의 파일을 비교한다. 이것은 두 개의 파일이 과연 어떻게 다른가를 중요시한다. 그래서 어떻게 수정되어야만 두 파일이 같아질 수 있는지를 말해준다. 

문법 
■ diff [ -ibefw ] 파일명1 파일명2 

옵션 
-i : 대소문자를 구분하지 않는다. 
-b : 하나 이상의 공백 문자는 모두 같은 것으로 취급해서 비교한다. 
-e : ed 에디터를 위한 스크립트를 생성한다. 
-f : 반대 순서로 스크립트를 생성한다. 하지만 이것은 ed 에디터에 사용될 수가 없다. 
-w : 탭(tab) 문자를 포함한 모든 공백 문자를 무시하고 비교 작업을 수행한다. 

설명 
diff가 보여주는 정보는 언뜻 보아서는 이해할 수 없다. 일단 명심해야 할 것은 표본이 되는 문서는 두 번째 파일이라는 점이다. 그래서 모든 정보는 ‘첫번째 파일이 어떻게 수정되어야 두 번째 파일과 같아지느냐’하는 것이다. 

파일2에서 파일1로 첨가(append)되어야 할 것은 ‘a' 기호로 표현된다. 그리고 파일1에서 제거(delete)되어야 하는 내용은 'd'로, 두 파일의 내용이 바뀌어(change)하는 내용은 ’c'기호로 표시한다. 이러한 수정 기호와 함께 행의 번호가 함께 표시되며, 해당 줄의 내용이 함께 출력된다. 
■ 행숫자 a 파일2시작행번호 파일2끝행번호 
■ 파일1시작행번호 파일1끝행번호 d 행숫자 
■ 파일1시작행번호 파일1끝행번호 c 파일2시작행번호 파일2끝행번호 

사용예 
■ $ diff -i doc1.txt doc2.txt 




du 
: 지정된 특정 디렉토리나 파일들이 차지하는 공간을 보고한다. 

문법 
■ du [ -sabxL ][ 디렉토리,파일명(들) ] 

옵션 
-s : 총 합계만을 따진다. 하위 디렉토리의 숫자 등은 나오지 않는다. 
-a : 크기가 계산된 각 파일의 크기를 보인다. 
-b : 바이트 크기로 출력한다. 
-x : 현재 디렉토리에 마운트된 파일 시스템만 검사된다. 
-L : 심볼릭 링크 자신의 공간 대신 연결된 파일의 크기를 다룬다. 

설명 
디렉토리나 파일을 지정하지 않으면 현재 디렉토리로 간주된다. 크기는 1K 바이트 크기의 블록으로 보고한다. 

사용예 
■ $ du /root ,,/root 디렉토리의 공간 크기를 보고한다. 



echo 
: echo는 인수로 지정된 문자열을 그대로 화면에 출력한다. 이것은 인수로 주어진 문자열이 오퍼레이팅 시스템으로 읽혀진 후에 다시 그대로 화면에 ‘메아리’치는 것으로 생각할 수 있다. 

문법 
■ echo [ -ne ] 문자열 

옵션 
-n : 새로 개행하지 않고 출력하게 한다. 
-e : 문자열 중에서 백슬래쉬와 조합되는 특수 문자를 인식하게 한다. 그러한 특수 문자들은 다음과 같은 것들이 있다. 

■ \a 밸소리 \b 백스페이스 
■ \f 용지바꿈(form feed) \n 행바꿈 
■ \r 0 칼럼으로(carriage return) \f 탭(tab) 
■ \v 수직 탭 \\ 백슬래쉬 문자 
■ \nnn 8진법으로 표기되는 ASCII 문자 \c 출력 후 행바꿈 금지 

설명 
일반적으로 echo 명령은 프롬프트 상에서 사용되는 일은 없다. 하지만 스크립트 작성시 번번히 사용된다. 셸 스크립트 상에서 echo 명령은 BASIC의 PRINT 명령이나 C 언어의 printf() 함수와 같이 메시지를 출력하는 데에 자주 사용된다. 또한 전혀 필요없을 것 같은 echo의 -n 옵션도 스크립트 상에서는 유용하게 사용될 수 있다. 

사용예 
■ $ echo "The RedHat !" 
■ The RedHat ! 
■ $ echo -e 'Linux\RedHat !' 
■ Linux RedHat ! 





ed 
: 풀 스크린 에디터를 사용할 수 없는 열악한 환경의 터미널을 위한 라인 에디터(line editor)이다. 

문법 
■ ed [ - ][ -s ][ -p문자열 ] 파일명 

옵션 
- : e, r, w, q, ! 명령에 의해 발생하는 메시지를 금지한다. 
-s : 검사 작업을 금지한다. 
-p문자열 : 프로프트를 원하는 문자열로 바꾼다. 

설명 
ed는 기능이 다양한 에디터이나 라인 에디터는 거의 사용할 일이 없을 것이다. 




env 
: 현재의 환경에 영향을 주지 않고 원하는 환경을 만들어 명령을 실행한다. 또는 현재의 환경을 보고한다. 

문법 
■ env [ - ][-i ][ -u 이름 ][ 이름=값 ][명령] 

옵션 
- : 뒤에 오는 이름=값 목록으로 환경을 제한한다. 
-i : 현재의 환경을 무시하고 빈 환경 상태로 시작한다. 
-u 이름 : 현재의 환경에 그 이름의 변수가 있다면 제거한다. 

설명 
‘이름=값’의 형식으로 특정 환경 변수를 지정해서 명령을 실행한다. 이러한 값을 필요한 대로 여러 개 나열하면 되고, 현재의 환경은 변경하지 않으므로 명령의 수행이 끝나면 환경의 상태는 이전과 다름없게 된다. 

사용예 
■ $ env HOME=/usr/victor tsh 

홈 디렉토리 변수를 지정하여 셸을 실행한다. 
■ $ env ,,현재 설정되어 있는 환경 변수들을 보여준다. 



file 
: 파일이 어떠한 형태의 파일인지 알아낸다. 

문법 
file [-czL ][ -fm 파일명 ] 파일명(들) 

옵션 
-c : 매직 파일의 파싱된 형태를 보여준다. 
-z : 압축되어 있는 파일의 형태를 검사한다. 
-L : 뒤따르는 심볼릭 링크를 야기시킨다. 
-f 파일명 : 검사한 파일에 대해 리포트를 만들 파일의 이름을 지정한다. 
-m 파일명 : 파일의 형태를 결정하는 데에 사용되는 매직 파일을 정한다. 

설명 
파일이 텍스트 문서인지 실행할 수 있는 파일인지 아니면 데이터 파일인지 등을 인식한다. 에디터를 사용해서 보거나 수정될 수 있는 파일인가 알아 보는 데에 많이 사용된다. 

사용예 
■ $ file -z /home/Book.Z 



find 
: 원하는 특정 파일을 디렉토리를 탐색하여 찾는다. find는 매우 강력한 도구로 특정 디렉토리들을 순회하면서 지정된 조건에 만족하는 파일을 찾는다. 파일의 조건은 이름이나 크기, 날짜 등 다양하게 지정할 수 있다. 

문법 
■ find [ 디렉토리 ] 탐색 조건 

탐색 조건 
-name 파일명 : 찾고자 하는 파일의 이름을 정한다. 와일드 카드도 가능하다. 
-perm 모드 : 파일 권한(permission)이 일치되는 것을 찾는다. 원하는 권한은 ls로 볼 수 있는 형태와 같이 지정한다. 
-type : 형태가 같은 파일을 찾는다. 물음표() 부분에 디렉토리는 d, 파이프는 p, 심볼릭 링크는 l, 소켓은 s, 블록 파일은 b, 일반 파일은 f 등의 기호를 사용한다. 
-links : 특정 개수의 링크를 가진 파일을 찾는다. 물음표 부분에 링크의 숫자를 표기한다. 
-size : 파일의 크기가 일치하는 것을 탐색한다. 파일 크기는 블록단위로 물음표 부분에 지정한다. 한 블록은 512바이트로 내정되어 있지만 블록 숫자 뒤에 단위로 k자를 붙이면 1키로바이트 크기의 블록 숫자로 간주된다. 
-user 사용자 : 파일 사용자의 ID에 따라서 검색한다. 로그인 이름이나 번호 모두가 가능하다. 
-atime : 최근 며칠내에 엑세스한 파일을 검색한다. 날짜수는 에 명시한다. 
-exec 명령 : 원하는 검색 조건에 맞는 파일을 찾으면 명시된 명령을 실행한다. 명령의 끝은 \;을 사용하여 끝낸다. find가 검색해낸 파일의 이름을 인수로 사용하고 싶다면 그 위치에 {}를 사용한다. 
-newer 파일 : 어떤 파일보다 최근에 갱신된 모든 파일을 검색한다. 

사용예 
■ $ find /bin -name ro* 
■ $ find -user qwfwq -exec cat {} list\; 



finger 
: 시스템 상의 사용자들에 대한 정보를 보여준다. 

문법 
■ finger [ -slpm ][ 사용자 ] 

옵션 
-s : 사용자의 로그온 이름, 실제이름, 터미널 이름, 로그온 시간 등등을 보인다. 
-I : -s 옵션 정보에 몇 가지를 추가하여, 여러 줄에 걸쳐서 보여준다. 
-p : -l 옵션 정보에서 .plan과 .project 파일을 보이지 않는다. 

설명 
인수로 아무 것도 주어지지 않으면, finger는 현재 시스템에 로그인되어 있는 사용자들을 보여준다. 옵션이 주어지지 않으면, 기본적으로 -l 옵션을 사용한 것으로 간주된다. 

사용예 
■ $ finger 
■ Login Name Tty Idle Login Time Office Office Phone 
■ blade kimtaihan 2 1 Oct 20 11:31 
■ root root 1 Oct 20 11:28 




fsck 
: 파일 시스템이 완전한 상태를 유지하고 있는가를 검사하고, 잘못된 것은 바로 잡는다. 

문법 
■ fsck [ -arsVN ][ 파일시스템 ] 

옵션 
-a : 검사도중 발견된 에러를 자동적으로 복구한다. 
-r : 검사도중 에러가 발견되면 복구할 것인가를 물어온다. 이것은 하위 호환성을 위한 것으로서 사실상은 사용되지 않는다. 
-s : 병렬적인 방법이 아니라 순차적인 방법으로 검색한다. 
-V : 검색중 각종 정보를 자세하게 보여준다. 
-N : 실제로 검사 작업을 하지는 않도록 한다. 

설명 
이것은 시스템이 처음 가동될 때 자동으로 호출된다. 이름은 file system check를 줄인 것으로, 파일 시스템을 스캔(scan)하여 일관성을 유지하고 있는가를 검사한다. 

디스크의 블록이 bitmap에는 사용되지 않은 상태로 표시되었음에도 불구하고 inode로부터 참조된다든지 반대로 사용된 블록으로 표시되었는데도 inode로부터 참조되지 않는 일이 있는가를 검색한다. 그 외에도 inode 링크계수가 올바른지 두 개 이상의 inode가 같은 블록을 참조하는지 혹은 블록번호가 유효한 것인가 등의 여러 가지를 검사한다. 

-a 옵션을 사용하였다면 검사도중 발견된 오류는 자동으로 복구된다. -r 옵션을 사용한다면 반드시 -s 옵션을 함께 사용해야 한다. fsck는 기본적으로 한꺼번에 몇 개의 검사를 병행하는 병렬 작업을 하기 때문에 하나의 에러를 발견하더라도 다른 검사는 계속 수행되고 있다. 검사 시간을 최대한 절약하기 위해서 병렬 작업을 하기 때문에 사용자의 수정과 다른 검사 작업의 호홉이 맞지 않을 수 있다. 그러므로 -s 옵션을 주어서 오직 하나의 검사 작업만 진행되도록 해야 한다. 그러나 -r 옵션은 하위 버전과의 호환성을 위한 것으로서 사용자는 -a 옵션만을 사용하는 것으로서 충분하다. 파일 시스템을 지정해 주지 않으면 /etc/fstab 파일에 나열된 파일 시스템을 검색한다. 



grep/fgrep 
파일내에서 특정 패턴을 검색한다. 이름은 Global Regular Express Printer 의 머리글자이다. 
문법 
■ grep [ -vclhnief ] 표현 파일명(들) 
■ fgrep [ -vclhnief ] 문자열 파일명(들) 

옵션 
-V : 일치되는 내용이 없는 라인을 표시한다. 
-C : 일치되는 내용이 있는 행의 개수를 센다. 
-I : 일치되는 내용이 있는 파일의 이름만을 표시한다. 
-h : 일치되는 내용을 찾은 파일의 이름을 표시하지 않는다. 
-n : 일치 내용이 있는 행은 행번호와 함께 표시된다. 
-i : 대소문자 구분을 하지 않는다. 
-e 표현 : 표현이 하이픈 문자로 시작될 때 사용한다. 
-f 파일 : 찾으려는 문장이나 표현이 있는 파일을 지시한다. 

설명 
원하는 탐색 단어 혹은 문장을 검색한다. 표현은 일반 표현식을 사용한다. fgrep은 문자열을 검색할 때 빠르게 사용할 수 있다. 

사용예 
■ $ grep catch myletter 

myletter에 catch라는 단어가 있는지 검사한다. 
■ $ grep "[Cc]atch" myletter 

앞 글자가 대소문자인지 상관하지 않고 catch라는 단어를 찾는다. 이것은 다음의 fgrep 명령과 같은 동작을 한다. 
■ $ fgrep catch myletter 



halt 
: halt는 아무런 경고없이 시스템을 즉시 종료시킨다. 

문법 
■ halt 

설명 
시스템이 halt되면 'System halted' 메시지가 나오고, 시스템은 정지한다. halt는 옵션을 가지지 않는다. 

명령이 내려지면 일련의 마무리 작업을 수행한 후에 정지한다. 시스템 종료 기록도 /var/adm/wtmp 로그 파일에 추가된다. 




head 
: 파일의 처음 부분을 출력한다. 

문법 
■ head [ -행수 ] [ 파일이름(들) ] 

옵션 
-행수: 출력될 행수를 지정한다. 

설명 
옵션으로 주는 행 숫자는 화면에 표시될 행의 개수를 의미한다. 만일 그것이 주어지지 않는다면 기본적으로 10개의 행을 출력한다. 

사용예 
■ $ cat letter 
■ 원일이에게. 
■ 안뇽 :-) 
■ 자네가 돈을 빌려간지도 1년이 넘었네. 
■ 난 포기 안하지. 
■ 하루속히 갚기를 바라네. 
■ 독촉해서 미안하군 
■ 건강하길... 
■ 1997년 모월 모일 친구가. 

문서의 앞 머리 세 줄만 확인하기 위해서 다음과 같이 할 수 있다. 
■ $ head -3 letter 
■ 원일이에게. 
■ 안뇽 :-) 
■ 자네가 돈을 빌려간지도 1년이 넘었네. 




hostname 
: 현재 설정되어 있는 호스트의 이름을 표시하거나 변경한다. 

문법 
■ hostname [ 호스트이름 ] 

설명 
이것은 인수없이 사용된다면 현재 설정되어 있는 호스트 이름을 보여준다. 리눅스는 기본적으로 프롬프트에서 호스트의 이름을 보여줄 것이다. 혹은 사용자가 프롬프트에 호스트 이름이 나타나도록 할 수도 있다. 인수로서 새로운 호스트 이름을 지정한다면 새로 지정된 이름으로 호스트 이름을 바꾼다. 하지만 이런 작업은 수퍼 유저만이 할 수 있다. 

사용예 
■ $ hostname 
■ Blade 


id 
: 시스템에 등록된 ID를 확인한다. 

문법 
■ id [ -gGnru ] 

옵션 
-g: 그룹 ID만을 출력한다. 
-G: 추가 그룹들만을 출력한다. 
-n: ID 번호대신 이름으로 출력한다. 
-r: 실제 사용자나 그룹 ID를 출력한다. 다른 옵션과 함께 사용한다. 
-u: 사용자의 ID만을 출력한다. 

사용예 
■ $ id -un 


jobs 
: 현 터미널에서 수행된 작업들을 간략하게 나열해준다. 

문법 
■ jobs [ -I ] 

옵션 
-I: 프로세서 번호를 추가해서 보여준다. 

설명 
jobs 명령에 대한 것은 fg와 bg명령에 대한 설명과 함께 3장을 참고하라. 
여기서는 프로세서 번호와 jobs 볼 수 있는 작업 번호에 대해 생각해 보자. 

작업번호는 한 사용자의 작업에 대한 것으로, 1번부터 순서대로 부여되지만 다른 터미널의 다른 사용자도 같은 번호의 job을 가지는 것이다. 또한 이 작업 번호는 중지되었거나 백그라운드에 있는 것들만이 작업 번호가 주어진다는 점이다. 프로세서 번호는 시스템 중심적이고, 작업 번호는 사용자 중심적인 번호인 것이다. 




join 
: 두 개의 정렬된 파일을 하나로 수평 병합한다. 
문법 
■ join [ -aejotv ] [파일명]1 [파일명]2 

옵션 
-an : 첫 번째나 두 번째 파일로부터 일치하지 않는것도 처리, n은 1이나 2이다. 
-e 문자열 : 비어 있는 필드는 문자열로 대체한다. 
-j n m : 파일n의 m번째 필드를 두 파일에 병합한다. 
-o 파일 : 명시된 파일의 형태에 따라서 출력을 만든다. 
-t 문자 : 필드 구분 문자를 정한다. 기본적으로 공백, 탭, 기행 문자다. 
-v 파일 : 파일1이나 파일2의 짝이 연결되지 않는 행을 지정된 파일로 출력한다. 

설명 
두 파일의 내용을 하나의 파일로 병합하는데, cat을 사용하는 것처럼 한 파일의 뒤에 다른 하나를 추가하는 것이 아니라 각 행끼리 붙이기를 한다. 
이 명령을 사용하면 두 개의 다른 데이터를 가진 목록을 합칠 수 있다. 




kill 
: 현재 수행중인 프로세서에게 시그널을 보낸다. 보통 kill 명령은 프로세서를 죽이는 데에 사용된다. 그래서 이 유틸리티의 이름도 kill이 되었다. 

문법 
■ kill [-signalID] PID 
■ kill -l 

옵션 
-signalID : 프로세서에게 보낼 시그널을 지정한다. 시그널은 번호로 지정될 수도 있고 시그널 이름으로 지정될 수도 있다. 
-l : 시그널 종류를 나열한다. 시그널의 종류는 시그널 번호 순서대로 이름으로 나열한다. 

설명 
시그널의 종류를 지정하지 않으면 프로세서를 종료시키는 의미로 디폴트 시그널 ID 15번을 보내게 된다. 

예를 들면 당신이 시스템을 사용을 마치고 로그아웃할 때는 시그널 ID 1번의 HUP(hang up) 시그널이 시스템으로 전달되며, 이 시그널은 당신의 셸 상태에서 실행중인 모든 프로세서를 종료시키고(앞에서 언급한 nohup에 의한 프로세서는 제외) 로그아웃하게 한다. 

사용예 

■ $ kill -l 
■1) SIGHUP 2) SIGNT 3) SIGQUIT 4) SIGILL 
■5) SIGTRAP 6) SIGIOT 7) SIGBUS 8) SIGPPE 
■9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 
■13) SIGPIPE 14) SIGALRM 15) SIGTERM 17) SIGCHLD 
■18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 
■22) SIGTTOL 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 
■26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 
■30) SIGPWR 

■$ kill -9 16034 
■$ kill -kill 16034 ,,두 명령은 같은 의미이다. 
■$ kill -9 0 

이것은 모든 프로세서를 종료시킨다. 



less 
: more와 유사하게 페이지 단위로 문서를 보여준다. 이것은 문서의 앞으로도 이동하는 것이 가능하다. 

문법 
■ less [ -acCeEinqQsx ] 파일명(들) 

옵션 
- : less에서 사용할 수 있는 명령들에 대한 도움말을 제공한다. 이 옵션이 사용되면 다른 인수는 무시되고, 도움말 화면을 보여준다. 
-a : 마지막 라인이 화면에 출력되고 나서 탐색을 시작한다. 
-c : 필요할 때 전체 화면은 다시 갱신한다. 
-C : -c 옵션과 같지만 갱신할 때 화면 전체를 지우고 시작한다. 
-e : 두 번째로 파일의 끝에 도달하면 자동적으로 종료한다. 
-E : 파일의 끝에 도달하기만 하면 자동적으로 종료한다. 
-i : 대소문자를 구분하여 탐색한다. 
-n : 행번호를 추가한다. 
-q : 특정 에러가 발생하지 않으면 아무 소리도 내지 않고 조용히 동작한다. 
-Q : 결코 아무 소리도 내지 않는다. 
-s : 연속되는 공백 라인은 하나의 행으로 처리한다. 
-x 숫자 : 수치를 지정해서 탭 간격을 조정한다. 기본값은 8이다. 

설명 
less는 많은 옵션과 키 사용법이 있다. 온라인 레퍼런스를 참조하기 바란다. 

사용예 
■ $ less lovemessage 


ln 
: 두 개의 파일 사이에 링크를 만들어, 하나의 파일을 두 개 이상의 이름으로 접근이 가능하도록 한다. 

문법 
■ ln [ -s ] 파일명1 파일명2 
■ ln 파일명들 디렉토리 

옵션 
■ -s : 하드 링크 대신 심볼릭 링크를 만든다. 

설명 
유닉스 파일 시스템의 링크 개념의 자세한 내용에 대해서는 다른 자료를 참고하라. 파일을 복사하는 대신 링크를 사용하면 디스크 공간을 매우 절약할 수 있다. 

위에서 보면 첫 번째 형식에서 파일명2는 원하는 링크 파일의 경로와 이름이 된다. 이것은 일종의 alias(별명)라고 생각할 수 있다. 두 번째 형식에서 파일명들은 링크되기 원하는 파일들의 이름이고, 디렉토리는 링크된 파일이 지정되기 원하는 위치이다. 링크에 익숙해지면 ln명령은 cp 명령을 사용하는 것처럼 간단하게 사용할 수 있을 것이다. 

사용예 
■ $ ln project theplan ,,두 개의 이름은 같은 문서를 의미한다. 




longname 
: 이것은 현재 시스템에서 당신이 사용하는 로그온 이름을 보여준다. 

문법 
■ longname 

설명 
longname은 옵션을 가지지 않는다. 이름은 /etc/utmp 파일을 알아낸다. 

사용예 
■ $ longname 




ls 
: 파일 시스템 상의 파일을 목록을 보여준다. 

문법 
■ ls [ -aCxdlstucriFR ][ 파일명(들) ] 

옵션 
-a : 도트로 시작되는 이름을 가진 파일명도 전부 보여준다. 
-C : 가로 순서로 나열하여 출력한다. 
-x : 세로 순서로 나열하여 출력한다. 
-d : 현재 디렉토리에 대한 정보를 출력한다. 
-l : 각 파일들에 대한 소유자, 권한, 갱신일 등의 자세한 정보를 출력한다. 
-s : 파일이 얼마나 많은 디스크 블록을 차지하고 있는가를 보여준다. 
-t : 파일 갱신일 순서대로 정렬한다. 
-u : 엑세스(access)한 날짜 순서대로 정렬한다. 
-c : inode가 마지막 바뀐 시간 순서대로 정렬한다. 
-r : 정렬된 순서의 역으로 출력한다. 
-i : 파일의 inode 번호를 보여준다. 
-F : 파일의 특성을 쉽게 알 수 있는 문자를 나타낸다. 는 실행 가능한 파일을, /는 디렉토리 이름을 의미한다. @는 심볼릭 링크를 나타내고, =는 소켓(socket)을 나타낸다. 하지만 여러분의 리눅스는 기본적으로 이러한 특성을 보여줄 것이다. 
-R : 현 디렉토리의 내용은 물론이고 서브 디렉토리의 내용까지 전부 보여준다. 

설명 
-l 옵션을 사용하여 볼 수 있는 정보 중 권한(permission) 정보 앞에 있는 파일 형태에 대한 기호는 다음과 같다. 

■ - 일반 파일 
■ d 디렉토리 
■ b 디스크의 같은 블록 형태의 장치 
■ c 터미널과 같은 문자 형태의 장치 
■ p 이름붙여진 파이프(pipe) 
■ s 세마포어(semaphore) 
■ m 공유메모리(Shared memory) 

사용예 
■ $ ls -la /root 




mail 
: 전자 우편을 사용하기 위해 mail이라는 명령을 사용한다. System V 같은 계열의 유닉스에서는 mailx라고 하기도 한다. BSD에서는 mail이라고 하며, 당연히 BSD 계열인 리눅스에서도 그렇게 부른다. 

문법 
■ mail [ -Hf ][ 사용자ID ] 

옵션 
-f : 편지가 수신된 파일을 지정하며, -f 옵션 뒤에 파일 이름을 지정한다. 

설명 
사용자 ID를 명시되지 않고, 인수없이 mail을 실행하면 수신된 편지를 읽을 수 있다. 편지는 mail 디렉토례 사용자ID 이름으로 만들어진 파일에 저장된다. 




man 
: 사용하고자 하는 유닉스 유틸리티에 대한 매뉴얼(manual)을 검색해서 보여준다. 

문법 
■ man [ 장 ] 단어 
■ man -k 키워드 

옵션 
-k : 인수로 주어진 단어를 키워드로 사용하여, 해당 키워드가 발견되는 모든 매뉴얼의 내용을 검색하여 보여준다. 

설명 
셸을 사용할 때 어떤 명령의 사용법이 기억나지 않는 경우가 있다. 혹은 매번 사용하던 명령이라도 특수한 옵션이 필요할 때 그 기호나 사용법을 정확히 확인해야 하는 경우가 많이 있다. 물론 참고 서적을 보면 되겠지만 터미널 상에서 필요한 도움말을 언제라도 제공받을 수 있다. 시스템에 내장된 매뉴얼은 빠르게 볼 수 있을 뿐만 아니라 그 내용도 완벽한 것이어서 옵션의 종류 같은 것은 빠진 것이 없다. 만일 온라인 레퍼런스를 모두 종이로 출력한다면 그 분량은 엄청날 것이 틀림없다. 

위에서 보인 첫 번째 형식은 매뉴얼의 장 번호를 이름과 함께 명시해서 검색할 수도 있다. 하지만 보통은 그것을 생략하고, 검색하고자 하는 제목만을 인수로 전달해서 사용한다. 그러면 자세한 내용을 볼 수 있을 것이다. 출력된 내용은 화살표 키를 사용해 위아래로 자유로이 스크롤할 수 있다. 

사용예 
■ $ man telnet 

mcd 
: MSDOS 시스템으로 현재 사용하는 디렉토리 장소를 이동한다. 

문법 
■ mcd dos디렉토리 

설명 
dos 디렉토리는 슬래쉬나 백 슬래쉬 모두 사용할 수 있으며, MSDOS에서 사용되는 백 슬래쉬(\)나 와일드 카드를 사용하려면 따옴표를 사용하여 셸이 번역하는 것을 미리 막아야 한다. 

사용예 
■ $ mcd a:/dos 




mcopy 
: MSDOS 파일 시스템으로 혹은 DOS 파일 시스템의 파일을 복사한다. 

문법 
■ mcopy [ -tnvm ] 파일명1 파일명2 

옵션 
-t : 텍스트 파일 복사시 CR/LF 문자를 \n 하나로 바꾼다. 
-n : 파일을 덮어쓰게 되는 경우에도 경고하지 않는다. 
-v : 자세히 안내문을 보여준다. 
-m : 파일 갱신 시간을 보존한다. 

사용예 
■ $ mcopy -t letter a:letter.txt 




mdel 
: MSDOS 파일 시스템에서 파일을 제거한다. 

문법 
■ mdel [ -v ] 파일명 

옵션 
-v : 진행되는 상황을 자세히 보여준다. 

사용예 
■ $ mdel a:/letter.txt 




mdir 
: MSDOS 디렉토리의 목록을 보여준다. MSDOS 프롬프트 상의 dir과 같은 동작을 한다. 

문법 
■ mdir [ -w ][파일명] 

옵션 
-w : 파일 크기나 생성 날짜는 제외하고 넓은 형식으로 보여준다. 

사용예 
■ $ mdir a:/dos 



mesg 
: 다른 터미널의 사용자가 당신에게 write 명령 등으로 메시지를 보낼 수 있는가 아닌가를 결정한다. 

문법 
■ mesg [ y or n ] 

옵션 
당신의 터미널이 다른 사용자의 메시지를 받기 원한다면 y, 그렇지 않다면 n을 선택한다. 옵션을 선택하지 않으면 mesg는 현재 터미널의 메시지 수신 가능 여부를 확인하여 알려준다. 보통 기본적으로 터미널은 메시지를 수신할 수 있다. 

사용예 
■ $ mesg ,,다른 이의 메시지를 수신할 수 있는지 알려준다. 
■ $ mesg n ,, 당신의 터미널이 메시지 수신을 거부하도록 한다. 




mkdir 
: 디렉토리를 새로 만들기 위해 mkdir 명령을 사용한다. 

문법 
■ mkdir [ -m mode ][ -p ] directory 

옵션 
-m : 디렉토리를 만들 때 같이 사용하여 사용자 권한을 줄 수 있다. 
-p : 만들 디렉토리의 상위 디렉토리까지 한꺼번에 만든다. 

사용예 
■ $ mkdir blade.seoul ,,현재 디렉토리의 하위 디렉토리 작성 
■ $ cd blade.seoul 
■ $ mkdir -p blade/books 

이것은 현재 디렉토리에서 하위 디렉토리 blade를 먼저 만든 후에 다시 그 하위 디렉토리로 books를 만든다. 




more 
한 화면씩 츨력을 보여주는 유틸리티, 한 번에 전체적으로 볼 수 없는 파일은 이것을 사용하여 스크롤을 제어할 수 있다. 

문법 
■ more [ -ncdflspu ][ 줄번호 ][ 파일이름(들) ] 

옵션 
-n : 여기서 n은 숫자를 의미하여, 숫자는 출력 윈도우의 행수를 지정한다. 
-c : 위에서부터 한 행씩 지운 후 한 행씩 출력한다. 보통은 화면 전체를 지운 후 각 행을 출력하기 시작한다. 특정한 터미널을 위해 사용한다. 
-d : 스페이스나 q 키를 누르라는 프롬프트를 출력한다. 
-f : 화면의 행이 아닌 논리적인 행 수를 계산한다. 보통은 긴 칼럼의 행은 화면에서 행바꿈을 하여 새로운 행으로 계산된다. -f 옵션을 사용하면 이러한 행은 계산하지 않는다. 
-s : 여러 개의 빈 공백행은 하나로 취급한다. 
-p : 스크롤하지 않는다. 대신 화면을 지우고 출력한다. 
-u : 밑줄 차기를 금지한다. 

설명 
more는 BSD에 있었으나 지금은 System V 등에도 있으며 리눅스는 물론이고 대부분의 유닉스가 기본적으로 가지고 있는 유틸리티이다. 기본적으로 more는 한 번에 한 페이지 단위로 파일의 내용을 출력한다. 

한 화면만큼 내용을 출력한 후 화면 하단에 ‘-More-' 라는 메시지를 출력하고는 잠시 출력을 중단한다. 다시 다음 페이지로 진행하기를 원한다면 스페이스바를 누른다. 또는 중단하기를 원한다면 q 키를 눌러라. 여러 개의 파일 내용을 연속적으로 보고자 한다면 원하는 여러 개의 파일 이름을 나열하면 된다. 

more 명령은 몇 가지 명령을 인식할 수 있다. 스페이스 바를 누르는 것을 포함해서 다음과 같은 조작을 하는 것이 가능하다. 

■ : 한 줄만 스크롤된다. 
■ D : 반 페이지만 뒤로 이동한다. 
■ : 한 페이지만 뒤로 이동한다. 
■ B : 한 페이지 앞으로 이동한다. 
■ H : 도움말을 제공한다. 
■ V : vi 에디터를 부른다. 에디터를 종료하면 원 위치로 돌아간다. 
■ Q : more 를 종료한다. 

사용예 
■ $ cat document.97 | more 

기본적으로 more 명령은 첫 번째 줄 내용부터 출력한다. 하지만 원하는 부분부터 출력을 원한다면 다음과 같은 방법으로 실행할 수 있을 것이다. 다음은 13번째 행부터 출력을 시작한다. 
■ $ more 13 loveletter.txt 




mount 
: 다른 파티션의 디스크나 물리적으로 다른 기억 장치를 파일 시스템으로 연결한다. 

문법 
■ mount [ -vwrnta ] 장치명 디렉토리 

옵션 
-v : 마운트 작업을 수행하면서 자세한 정보를 출력한다. 
-w : 마운트되는 파일 시스템을 읽기와 쓰기가 가능하도록 한다. 
-r : 마운트되는 파일 시스템이 읽기 동작만 가능하도록 한다. 
-n : 마운트 정보가 기록되는 /etc/rntab 파일에 정보를 기록하지 않는다. 
-a : /etc/fstab 파일에 있는 모든 파일 시스템을 마운트하도록 한다. 
-t 형태 : 마운트되는 파일 시스템의 형태를 지정한다. 

설명 
마운트 개념은 다른 PC용 오퍼레이팅 시스템에 비해 매우 우수한 개념이라 할 수 있다. 사용자는 다른 오퍼레이팅 시스템도 마운트하여 접근할 수 있다. -t 옵션을 사용하여 그 형식을 지정하면 대부분이 형식이 가능하다. -t 옵션으로 지정할 수 있는 형태는 msdos, hpfs, minix, ext, ext2, proc, nfs, umsdos, sysv 등으로 사용자가 원하는 모든 파일 시스템이 접근할 수 있을 것이다. 현재 시스템에 마운트된 장치의 정보는 /etc/mtab 파일에 저장되어 있다. 

사용예 
다음의 사용예는 다른 파티션 영역을 차지하고 있는 DOS 파일 시스템을 마운트하는 것이다. 사실, 이것은 필자가 리눅스를 설치하고 나서 실제로 했던 작업을 그대로 적어놓은 것이다. /dev/hda1 이 의미하는 바에 대해서는 본문을 참조하라(물론 이것은 독자가 설치한 방식에 따라서 다를 것이다.) 하드 디스크의 이 영역에는 Windows 95가 설치되어 있는데, 이것도 DOS 파일 시스템 형식으로 접근이 가능하며 파일의 읽기와 쓰기가 자유롭다. 
■ $ mount -t msdos /dev/hda1 /mswin 




mv 
: 파일의 위치를 이동하거나 파일의 이름을 바꾸어준다. 

문법 
■ mv [ -fi ] 파일명1 파일명2 
■ mv [ -fi ] 파일명(들) 디렉토리명 

옵션 
-f : 같은 이름의 파일이 존재하고 쓰기 권한이 금지되어 있더라도 물어보지 않고 덮어쓰기를 해버린다. 이런 경우 이 옵션을 사용하지 않으면 사용자에게 다시 확인을 할 것이다. 
-i : 파일을 덮어쓰기 전에 사용자에게 확인한다. 

설명 
기존에 있던 파일을 원치않게 잃어버리는 수가 있기 때문에 확실하지 않다면 -i 옵션을 사용하는 것을 권한다. 

사용예 
■ $ mv sisap.hong victor.dongki readme.txt ../friend 
■ $ mv blade.Z ../kimtaihan.Z 
■ $ mv /home/blade /home/friend 

만일 어떤 파일을 현재의 위치에서 다시 현재의 위치로 이동한다면 어떤일이 일어날까 고민할 것 없다. 답은 당연히 ‘아무 일도 일어나지 않는다’ 이다. 이것은 어떤 의미를 가지지 못한다. 하지만 파일 이름을 바꾸면서 현재의 위치로 ‘이동’한다면, 그것은 파일의 ‘이름을 변경’ 하는 것과 같은 효과를 거둘 것이다. 

■ $ mv sisap.doc LeeKiHong.doc 

newgrp 
: 현재 그룹 ID를 변경한다. 

문법 
■ newgrp 그룹명 

설명 
이 명령을 사용하여 다른 특성 그룹들의 파일을 다룰 수 있다. 그룹을 바꾸면 패스워드를 물어오는 프롬프트가 나타난다. 그러면 그에 해당하는 그룹 패스워드를 입력해야 한다. 

■ No such group : No such file or directory 

이것은 당신이 바꾸고자 하는 그룹 이름이 존재하지 않는다는 것이다. 그룹 이름을 잘못 지정하면 이러한 메시지를 볼 수 있을 것이다. 




passwd 
: 자신의 패스워드를 관리한다. 

문법 
■ passwd [ user ] 

설명 
passwd를 부르면서 사용자 이름을 지정하면 그 사용자의 암호를 관리할 수 있다. 물론 이것은 슈퍼 유저만이 할 수 있는 일이다. 암호는 암기하기는 쉬워야 하지만 타인이 추측하기는 어려워야 한다. 보통은 아무 인수없이 명령을 사용하며 암호를 바꿀 것인지 아닌지를 선택할 수 있다. 

사용예 
■ $ passwd 




paste 
: 하나 혹은 그 이상의 파일로부터 칼럼 형태의 출력을 만든다. 이것은 cut과 함께 사용되는 경우가 많다. 

문법 
■ paste [ -s ][ -d구분문자 ] 파일명(들) 

옵션 
-s : 각 파일을 순회하면서 paste를 수행한다. 
-d구분문자 : 어떠한 문자로 칼럼을 구분하는지 지정한다. 기본값은 탭 문자이다. 

설명 
paste를 사용할 때 서로 붙여지는 파일명을 지정하는데, 이때 하이픈(-)으로 생략하면 표준 입력을 받아들이겠다는 뜻이 된다. 또한 paste의 출력은 항상 표준출력 장치로 나아간다. 

사용예 
■ $ paste -d' ' namelist.tmp /home/data.tmp 
두 개의 파일을 칼럼으로 합치고 그것을 화면으로 출력한다. 




ps 
: 유닉스는 동시에 여러 개의 프로세서가 동작되기 때문에 사용자가 그것들의 목록과 상태를 점검할 필요가 있다. ps라는 이름은 processor status를 의미한다. ps를 사용하여 프로세서들의 상태를 점검할 수 있다. 

문법 
■ ps [ -lujsvmaxScewhm ] 
■ ps [ -txx ] 

옵션 
-l : 자세한 형태의 정보를 출력한다. 
-u : 각 프로세서의 사용자 이름과 시작 시간을 보여준다. 
-j : 작업 중심 형태로 출력한다. 
-s : 시그널 중심 형태로 출력한다. 
-v : 가상 메모리 중심 형태로 출력한다. 
-m : 메모리 정보를 출력한다. 
-a : 다른 사용자들의 프로세서도 보여준다. 
-x : 로그인 상태에 있는 동안 아직 완료되지 않은 프로세서들을 보여준다. 유닉스 시 스템은 사용자가 로그아웃하고 난 후에도 임의의 프로세서가 계속 동작하게 할 수 있다. 그러면 그 프로세서는 자신을 실행시킨 셸이 없이도 계속 자신의 일을 수행한다. 이러한 프로세서는 일반적인 ps 명령으로 확인할 수 없다. 이때 -x 옵션을 사용하면 자신의 터미널이 없는 프로세서들을 확인할 수 있다. 
-S : 차일드(child) CPU 시간과 메모리 페이지 결함(fault) 정보를 추가 한다. 
-c : 커널 task_structure로 부터 명령 이름을 보여준다. 
-e : 환경을 보여준다. 
-w : 긴(wide) 형태로 출력한다. 한 행 안에 출력이 잘리지 않는다. 
-h : 헤더를 출력하지 않는다. 
-r : 현재 실행중인 프로세서를 보여준다. 
-n : USER 와 WCHAN 을 위해 수치 출력을 지원한다. 

설명 
기본적으로 ps는 현재 명령이 내려지는 셸에서 만들어진 프로세서들의 목록만을 보여준다. ps는 자신이 실행되는 당시, 현재의 셸에 의해서 수행된 프로세서들을 검사하고 보고한다는 점을 생각하자. 그러면 ps의 출력결과 리스트에 ps 자신이 있는 이유를 쉽게 이해할 수 있을 것이다. 각 필드의 의미는 다음과 같다. 

■ COMMAND : 명령어의 이름 
■ PID : 프로세서 ID, 각 프로세서를 구분하기 위한 고유의 ID 
■ RSS : 프로세서에 의해 사용되는 실제 메모리의 용량(K byte 단위) 
■ USER : 프로세서를 실행시킨 소유자의 계정을 보여준다. 
■ SZ : 프로세서의 자료와 스텍 크기의 (K byte 단위) 
■ TIME : 현재까지 사용된 CPU의 시간(분,초) 
■ TT : 프로세서의 제어 터미널(t3=/dev/tty3) 
■ %CPU : 마지막 분동안 프로세서가 사용한 CPU시간의 백분율 
■ START : 프로세서가 시작된 시간 
■ STAT : 프로세서의 상태 

이중 STAT 필드는 몇 가지의 부호를 사용해서 프로세서의 상태를 표시하고 있다. 그것들을 정리해 보면 다음과 같다. 

■ P : 수행 가능/수행중 
■ T : 일시 정지 
■ D : 디스크 입출력 대기 같은 인터럽트할 수 없는 대기상태 
■ S : 20초 미만의 짧게 잠듦(sleep) 
■ I : 20초 이상의 길게 잠듦 
■ Z : 좀비(zombi) 프로세서 

좀비(zomb) 상태라는 것은 프로세서가 사라질 때 시그널 처리의 문제로 완전히 소멸되지 못한 상태를 말한다. 

사용예 
$ ps 




pwd 
: 현재 작업하는 디렉토리를 알기 위해서 pwd 명령을 사용한다. 

문법 
■ pwd 

설명 
현 디렉토리(current directory)가 무엇인지 보여준다. 

사용예 
■ $ pwd 
■ /home/blade 




reboot 
: 시스템을 리부팅한다. 

문법 
■ reboot [ -q ] 

옵션 
-q : 현재의 프로세서들을 종료시키지 않고, 부팅 동작만을 수행한다. 이 옵션을 사용하면 더 빠르게 리부팅할 수 있다. 다시 부팅한 기록은 로그 파일인 /var/adm/wtmp에 기록된다. 

설명 
이것은 모든 사용자 프로세서를 종료시키고 디스크로부터 리눅스를 다시 부팅한다. 시스템을 리부팅하기 위해 shutdown 명령의 -r 옵션을 사용할 수도 있지만 그보다 reboot 명령을 사용하는 것이 더 편리해 보인다. 

사용예 
■ $ reboot 




rcp 
컴퓨터 사이에서 파일을 복사할 때 사용된다. “remote cp"에서 이름이 유래한다. 

문법 
■ rcp [ -rpkx ] 파일명1 파일명2 
■ rcp [ -rpkx ] 파일명들 디렉토리 

옵션 
-r : 하위 디렉토리까지 재귀적으로 모두 복사한다. 
-p : 파일의 시간과 모드를 보존한다. 
-k : kerberos ticktets을 요구한다. 
-x : 복사되는 모든 데이터에 암호화 과정을 거친다. 

설명 
원격 파일과 원격 호스트 이름은 콜론을 사용하여 구분한다. 마지막 인수가 디렉토리 이름이라면 지정된 모든 파일들은 그곳으로 복사된다. 

사용예 
■ $ rcp victor.com:/root/* /home/victorfile 
■ 원격 호스트 victor.com의 /root에 있는 모든 파일들을 자신의 컴퓨터에 있는 디렉■ 토리 /home/vitorfile로 복사한다. 




rm 
파일을 지우는 명령이다. 이것은 remove의 의미를 가진 이름임을 기억하라. 

문법 
■ rm [ -firv ] 파일명 

옵션 
-f : 보통 지울 수 있는 권한이 없으면 안되지만, 이 옵션을 사용하면 성가신 작업을 하지 않고서도 강제로 파일을 지울 수 있다. 
-i : 파일을 지울 것인가 다시 물어본다. 지우기를 원한다면 y를 누른다. 
-r : 서브 디렉토리의 파일도 모두 재귀적으로 지운다. 
-v : 파일을 지우기 전에 파일의 이름을 나타내준다. 

설명 
rm 명령의 동작은 정확히 말해서 ‘파일의 레이블을 삭제한다’라고 말할 수 있다. 단순히 파일을 지운다고 말하는 것은 틀릴 수도 있는 것이다. 왜냐하면 유닉스 상에서는 하나의 파일이 여러 다른 디렉토리에서 동시에 여러개의 이름을 가질 수 있기 때문이다. 만일 어떤 파일이 세 개의 레이블을 가지고 있다면 rm 명령으로 하나의 레이블을 지우는 것은 그 파일 자체를 지우지는 못한다. 다른 두 개의 파일 이름이 아직 유효하기 때문이다. 다시 두 번째 레이블을 지우더라도 파일은 하나의 파일 이름을 가지고 살아있으며, 마지막 하나의 파일 이름이 제거될 때에만 파일은 지워지는 것이다. 

사용예 
■ $ rm blade.Z 
■ $ rm report.txt tempfile object.mainroutine hello.java 
■ $ rm -r blade ,, blade와 하위 디렉토리 파일 모두를 제거 




rmdir 
원하는 디렉토리를 제거한다. 

문법 
■ rmdir [ -p ] 디렉토리 

옵션 
-p : mkdir의 -p 옵션의 반대 동작으로 하위 디렉토리와 그 상위 디렉토리 모두를 제거할 수 있다. 이때 모든 디렉토리는 비워져 있어야 한다. 수행 후 결과가 어떻게 되었는지를 보여준다. 

설명 
제거하기를 원하는 디렉토리는 미리 모든 파일들이 비워져 있어야 한다. 이러한 작업을 편리하게 하기 위해서는 파일을 지우는 명령인 rm 명령을 -r 옵션과 사용하면 된다. 

사용예 
■ $ rmdir -p sisap/books 
디렉토리가 비워져 있다면 books를 제거한 후 sisap을 제거한다. 




shutdown 
시스템을 종료할 때 일반적으로 사용되는 명령이다. 

문법 
■ shutdown [ -thnrfck ] 시간 [ 메시지 ] 
■ shutdown now 

옵션 
-t n : t 옵션 뒤에 n초를 명시해서, 경고 메시지를 보낸 후 n초 후에 kill 시그널을 보낸다. 
-h : shutdown시 halt를 실행하게 한다. 
-n : 디스크 동기화 동작의 수행을 금지한다. 이런 옵션은 보통 사용할 일이 없을 것이다. 
-r : 시스템 종료를 완료하고 나서 다시 부팅 과정을 수행한다. 
-f : 빠른 리부팅을 한다. 리부팅시 파일 시스템 검사를 하지 않는다. 
-c : 이미 예약되어 있는 shutdown을 취소한다. 이 옵션을 준다면 시간 인수는 줄 수 없다. 하지만 메시지는 사용자들에게 줄 수 있다. 
-k : 모든 동작을 제대로 수행하지만 시스템을 종료할 시간이 되면 아무 것도 하지 않는다. 보는 사람으로 하여금 ‘절로 누구 놀리나’하는 말이 나오게 한다. k는 ‘just kidding'의 의미라고 한다. 

설명 
요즘은 컴퓨터를 끄기 전에 반드시 shutdown 절차를 거쳐서 시스템을 정리해야 한다는 것이 상식으로 통한다. 8비트 컴퓨터를 사용할 때는 그런 복잡한 것은 생각하지 않아도 문제 없었는데 말이다. 하드웨어와 스위치를 내리는 데에 소프트웨어의 허락을 받아야만 하는 것이다. shutdown 명령은 미리 사용자들에게 경고만을 보내고, 정해진 시간에 시스템을 종료한다. 시간은 24시간 단위의 표기법을 사용하며 종료 5분전에는 시스템에 로그인이 금지된다. 시스템 종료 시간이 가까워짐에 따라 각 사용자들에게 메시지를 주기적으로 출력하여 경고를 보낸다. 

사용예 
다음은 밤 11시 30분에 시스템을 종료하도록 예약하며 사용자들에게 그것을 알린다. 
■ $ shutdown 23:30 System will be down at 11:30 PM!! 
시간을 명시할 때 now를 사용하면 곧바로 시스템을 종료한다. 리눅스 사용자들은 컴퓨터를 끄기 전에 이렇게 하면 간단하다. 혼자 사용하고 있을 때 번거로운 과정은 필요 없을 테니까 말이다. 




sleep 
sleep이라는 명령은 이름 그대로 잠자는 일 외에는 하는 일이 없다. 

문법 
■ sleep 시간 

설명 
시간은 초 단위의 정수 숫자이다. 전면(foreground)에서 수행된다면 사용자의 터미널은 정해진 시간만큼 잠을 잘 것이다. 물론 정해진 시간에 즉각 일어나니 안심해라. 원한다면 ^C로 흔들어 깨울 수도 있다. sleep을 사용하는 가장 좋은 예는 3장에서 본 것과 같이 다중 작업을 시행할 때이다. 

다음과 같은 확인자를 사용한다면 다른 시간 단위를 사용할 수 있다. 

S 초 m 분 
h 시간 d 날짜 




sort 
파일내의 단어 순서를 행 단위로 정렬한다. 

문법 
■ sort [ -cmuodfiMnrtb ] 파일이름(들) 

옵션 
-c : 파일이 정렬되었는지 검사한다. 그렇다면 아무런 출력도 하지 않는다. 
-m : 특정한 파일을 병합한다. 파일은 이미 정렬되었다고 가정한다. 
-u : 고유한 행만이 출력된다. 
-o 파일명: 출력 파일 이름을 지정한다. 이름은 입력 파일 이름과 같을 수 있다. 
-d : 사전(dictionary)과 같은 순서대로 정렬한다. 단어 정렬 순서에는 문자, 숫자, 공백 문자만이 사용된다. 
-f : 대문자와 소문자를 구별하지 않는다. 
-i : 정렬에 사용되는 문자 중 프린트될 수 없는 문자는 사용하지 않는다. 
-M : 단어를 정렬할 때 달을 의미하는 문자를 취급한다. FEB는 JAN보다 뒤에 정렬된다. 
-n : 숫자를 같은 문자가 아닌 정말로 숫자로 취급해서 수의 크기대로 정렬한다. 
-r : 역순으로 정렬한다. 
-t 문자 : 단어 등 필드를 구분하는 문자를 지정한다. 탭(tab)이나 공백 문자 이외의 문자를 구분 문자로 취급하도록 한다. 
-b : 단어의 뒤에 오는 공백 문자는 정렬 키(key) 값으로 무시하도록 한다. 

설명 
sort명령의 정렬 방법에는 다음과 같은 기준이 있다. 
일반적인 알파벳 순서로 정렬하되 소문자보다 대문자가 우선한다. 
대소문자 보다 숫자가 우선한다. 숫자는 처음에 오는 숫자의 순서에 의한다. 즉 숫자들도 문자처럼 취급될 뿐이지, 실제 숫자의 대소는 생각하지 않는다. 

사용예 
■ $ cat sample 
■ speaker 
■ audio system 
■ Hi-Fi video 
■ 1997 
■ 4th object 
■ good! 
■ $ sort sample ,, 문자를 정렬 
■ $ cat sample ,, 분류된 내용 확인 
■ 1997 
■ 4th object 
■ Hi-Fi video 
■ audio system 
■ good! 
■ speaker 

split 
텍스트 파일을 작은 조각으로 나눈다. 너무 커서 다루기 불편한 텍스트 문서를 나눌 때 사용된다. 

문법 
■ split -행 수 파일명 [ 태그명 ] 

옵션 
-행 수 : 몇 개의 행 단위로 조각을 나누는지 정한다. 

설명 
파일이 나누어지면 나누어진 파일들의 접미사는 순서대로 .xaa .xab .xac ...와 같이 붙여진다. 만일 태그 이름을 지정한다면 사용자가 지정한 태그 이름은 기본값 태그 이름의 x 문자를 대체하게 된다. 태그 이름을 block이 라고 준다면 나누어진 파일들은 .blockaa .blockab .blockac 등과 같은 접미사를 가질 것이다. 

사용예 
■ $ split -400 project.a pro 
project.a 파일을 400행 단위로 나눈다. 첫 조각의 접미사는 .proaa가 된다. 




su 
다른 사용자 계정으로 서브 셸을 생성한다. 잠시만 다른 사용자 계정으로 작업할 필요가 있을 때 사용한다. 

문법 
■ su [ - ] [ 사용자ID ][인수] 

옵션 
- : 하이픈 (-)을 사용하면 새로운 셸로 로그인할 때 자신의 로그인 과정을 수행한다. 옵션이 주어지지 않으면 새로운 셸은 단지 셸 역할을 수행할 뿐이다. 

설명 
아무런 인수없이 su를 사용하면, 이것은 root 계정으로 로그인하기를 원하는 것으로 간주된다. 그래서 많은 사람들이 su가 ‘super user'를 의미하는 말로 생각하지만, 사실은 ’substitute user'를 의미하는 말이다. 물론 수퍼 유저의 패스워드를 알고 있어야만 한다. 

su의 인수로 원하는 사용자의 ID를 주면 그 사용자의 패스워드를 물어오고, 입력한 패스워드가 일치한다면 새롭게 생성된 셸을 볼 수 있다. 그렇게 다른 사람으로 작업한 후에 exit등으로 셸을 종료하면 다시 이전에 작업하던 셸로 돌아갈 수 있다. 이 명령은 혼자서 시스템을 사용하는 리눅스 사용자들에게 매우 유용하다. 기본적으로 일반 사용자 계정으로 작업하다가 필요한 경우 수퍼 유저로 로그인하고서 필요한 일이 끝나면 다시 일반 계정 셸로 돌아갈 수 있기 때문이다. 

사용예 
■ $ whoami 
■ blade 
■ $ su sisap 
■ Password: ,,여기서 sisap의 패스워드를 입력 
■ $ whoami 
■ sisap 
■ $ exit ,,sisap의 셸을 종료 
■ exit 
■ $ whoami 
■ blade 




sync 
현재 시스템 디스크의 IO 버퍼에 있는 디스크 이미지를 하드 디스크로 기록한다. 

문법 
■ sync 

설명 
시스템을 다운시키기 전에 버퍼에 있는 이미지를 반드시 디스크로 기록해야 한다. 그렇지 않으면 디스크는 기록된 정보의 이미지와 일치하지 않는 이미지를 가지게 될지도 모른다. 사실, 이것을 사용할 경우는 극히 드물다. 왜냐하면 shutdown등의 동작을 수행하면 그들이 자동적으로 sync를 호출하기 때문이다. 

사용예 
■ $ sync ,, 버퍼의 내용을 디스크로 기록한다. 





tail 
문서의 끝 부분을 화면에 출력한다. 

문법 
■ tail [ -행수 ] [파일이름들] 

옵션 
- 행수 : 출력될 행수를 지정한다. 

설명 
옵션으로 주는 행 숫자는 화면에 표시될 행의 개수를 의미한다. 만일 그것이 주어지지 않는다면 기본적으로 10개의 행을 출력한다. 

사용예 
head 명령을 설명하면서 사용한 문서 파일을 다시 사용해 보자. 

■ $ tail - letter 
■ 건강하길... 
■ 1997년 모월 모일 친구가 




tar 
마그네틱 테이프 기록 장치를 위한 명령이다. 파일을 테이프 기록장치로 기록하거나 읽어온다. 

문법 
■ tar 동작 [ 옵션 ] 플래그인수 파일명(들) 

설명 
테이프와 같은 순차적 기록 장치는 디스크와는 특성이 다르다. tar명령과 마그네틱 테이프에 대한 내용은 다른 자료를 참고하기 바란다. 리눅스를 사용하는 사람들은 테이프 기록 장치를 사용하는 경우는 거의 없을 것이다. 

사용예 
■ $ tar cf /home/blade/data.tar /home/blade/data 






tcsh 
tcsh는 bash와 마찬가지로 리눅스에서 사용하는 c 셸 명령 번역기이다. bash 셸이 표준 Bourne 셸에 기능을 보강한 것처럼, 이것은 C 셸의 확장판으로 생각할 수 있다. 리눅스 사용자는 tcsh를 이용해서 C 셸을 사용할 수 있다. 

문법 
■ tcsh [ -cefinstvxTVX ] [ 파일명 ] 

옵션 
-T : tenex라고 하는 특수한 기능을 수행하도록 한다. 
-V : -v 옵션과 같지만 초기화 스크립트의 수행에도 영향을 미친다. 
-X : -x 옵션과 같지만 초기화 스크립트의 수행에도 영향을 미친다. 

나머지 옵션들은 bash셸과 같다. 본문 4장에서 bash 셸의 옵션에 대해 설명한 부분을 참조하라. 

설명 
C 셸은 Bourne 셸 이후에 만들어진 셸로, 캘리포니아 버클리 대학에서 만들었다. 또한 리눅스에서 tcsh는 csh라는 이름의 링크 파일을 가지고 있다. 

표준적인 C 셸의 이름이기 때문이다. 셸에 대한 내용과 bash에 대한 사용을 참조하라. 




tee 
파이프 연결 출력을 양방향으로 나눈다. 

문법 
■ tee [ -ia ] 파일명(들) 

옵션 
-i : 인터럽트를 무시하도록 한다. 
-a : 지정된 파일들로 출력이 덮어쓰지 않고, 뒤에 추가되도록 한다. 

설명 
이것은 파이프 연결 흐름을 두 개의 방향으로 갈라지도록 한다. 마치 파이프를 연결할 때 사용되는 T자 연결관과 같다. 

사용예 
■ $ ls -l | tee list.output | more 
파일 목록을 list.output이라는 파일에 기록함과 동시에 more를 사용하여 화면으로 ls 출력 내용을 볼 수 있다. 




test 
파일의 각종 상태를 검사하여 결과를 알려준다. 이것은 셸 스크립트 상에서 if 문이나 while 문 등과 함께 사용되는 것이 보통이다. 

문법 
■ test 표현식 
■ [ 표현식 ] 

표현식 
■ -r 파일명 : 파일이 읽기 권한이 있으면 참 
■ -w 파일명 : 파일이 쓰기 권한이 있으면 참 
■ -x 파일명 : 파일이 실행하기 권한이 있으면 참 
■ -f 파일명 : 파일이 일반(regular) 파일이면 참 
■ -d 파일명 : 파일이 디렉토리이면 참 
■ -b 파일명 : 파일이 존재하고 블록 장치 파일이면 참 
■ -c 파일명 : 파일이 문자 전용 파일(character special file)이면 참 
■ -u 파일명 : 파일이 set-user-ID 플래그가 세트되어 있으면 참 
■ -g 파일명 : 파일이 set-group-ID 플래그가 세트되어 있으면 참 
■ -k 파일명 : 파일이 sticky 비트가 세트되어 있으면 참 
■ -s 파일명 : 파일의 크기가 0보다 크면 참 
■ -t 파일 디스크립터 : 파일 디스크립터에 해당하는 파일이 열려 있고, 터미널 장치로부터 사용되고 있으면 참, 기본 디스크립터 값은 1이다. 
■ -z 문자열 : 문자열의 길이가 0이면 참 
■ -n 문자열 : 문자열의 길이가 t 이상이면 참 
■ 문자열 1 = 문자열2 : 문자열1과 문자열2가 같으면 참 
■ 문자열 1 != 문자열2 : 문자열1과 문자열2가 다르면 참 
■ 문자열 : 문자열이 널(null)이 아니면 참, 널 문자열이면 거짓 
■ 정수1-eq정수2 : 두 개의 정수1과 정수2가 같으면 참 
■ 정수1-ne정수2 : 두 정수가 다르면 참 
■ 정수1-gt정수2 : 정수1이 정수2 보다 크면 참 
■ 정수1-ge정수2 : 정수1이 정수2 보다 크거나 같으면 참 
이외에도 -lt(작으면) -le(작거나 같으면), !(논리부정), -a(AND), -o(OR) 등과 같은 표현을 사용할 수 있으며, 괄호를 사용할 수도 있다. 

설명 
표현 방식이 두 가지가 있는데, 첫 번째 형식은 test 명령을 사용하는 것이고 두 번째 표현 방식은 대괄호를 사용하여 표현식을 기술하는 것이다. 물론 두 번째 방식이 더욱 많이 사용된다. 스크리트 상에서 판독력이 훨씬 좋기 때문이다. test는 표현식을 주지 않으면 에러 메시지를 발생한다. 

사용예 
■ if [ -d blade.room ] 
■ then 
■ cd blade.room 
■ echo "It's changed to the blade.room" 
■ fi 
셸 스크립트에 대한 부분을 참고하고, 자신이 직접 test 구문을 사용한 스크리트를 작성해 보라. 




time 
프로그램이 수행되는 시간을 측정한다. 

문법 
■ time 명령 

설명 
time의 인수로 측정하고자 하는 명령을 준다. time은 세 가지 다른 형태의 시간 측정 결과를 보고한다. 실제로 얼마만큼의 시간이 걸렸는가 하는 real 커널이 사용한 시간을 제외하고 CPU에서 소비된 시간을 나타내는 user그리고 실제로 얼마만큼의 커널 시간을 할애했는가 하는 sys시간이 있다. sys user 시간이 실제로 작업에 할애된 시간이며, real 값에서 sys user 값을 뺀 결과값은 다른 프로세서 처리에 할당된 시간이다. 

사용예 
■ $ time cc project.c 
컴파일하는 데에 걸리는 시간을 측정한다. 




touch 
파일의 엑세스 시간이나 갱신 시간을 수정한다. 

문법 
■ touch [ -amc ] MMDDhhmmYY 파일명(들) 

옵션 
-a : 파일의 엑세스 시간을 바꾼다. 
-m : 파일의 갱신 시간을 바꾼다. 
-c : 파일명이 존재하지 않는다면 새로운 파일을 만들지 않는다. 

■ MM : 월 DD : 날짜 
■ hh : 시간 mm : 분 YY : 연도 

설명 
지정된 파일들의 시간을 바꾼다. 옵션을 지정하지 않으면 엑세스 시간과 갱신 시간 모두를 바꾼다. 즉 디폴트 옵션은 -am이다. 지정된 파일의 이름이 없다면 명시된 시간을 가지는 새로운 파일을 생성한다. 

사용예 
■ $ touch -a 0615120097 bladenote 
파일의 엑세스 시간을 97년 6월 15일 12시로 변경한다. 




tr 
특정한 문자들을 다른 문자로 변경한다. 대부분 리다이렉션과 함께 사용한다. 

문법 
■ tr [ -cd ] 변경할 문자 변경문자 

옵션 
-c : 파일의 모든 내용을 보이지 않고 바꾸는 작업만 보여준다. 
-d : 파일에서 변경할 문자를 제거한다. 

설명 
문자 표현시 백슬래쉬 문자 뒤에 8진법 숫자를 써서 문자 코드를 표현할 수 있다. 또한 [c1-c2]와 같은 하이픈 표현으로 문자의 범위를 지정할 수 있으며 [c*n]과 같은 방법으로 n 만큼의 문자 반복을 표현할 수도 있다. 변경할 문자의 변경 문자의 개수는 같아야 한다. 

사용예 
■ $ tr -d "\015\032" readme.txt readable 
readme.txt의 파일에서 캐리지 리턴 문자와 eof마크를 제거하고 readable파일로 리다이렉션한다. 




true 
셸 상에서 참의 의미를 가지는 0을 반환한다. 

문법 
■ true 

설명 
셸 스크립트 상에서 무한 루프를 만들 때 등의 경우 사용될 수 있다. Bourne 셸 상에서는 콜론 문자(:)로 같은 효과를 얻을 수 있다. 

사용예 
다음의 스크립트는 무한정 문자를 출력한다. 
■ while true 
■ do 
■ echo -e "over and over..." 
■ done 




tty 
현재 로그온되어 있는 터미널의 장치 이름을 알려준다. 

문법 
■ tty [ -s ] 

옵션 
-s : 표준 입력이 터미널 장치인지 아닌지를 시험한다. 터미널이 표준이라면 0을 반환하며 아니라면 1을 반환한다. 

설명 
만일 -s 옵션을 사용하지 않고서 tty를 입력했을 때 표준 입력 장치가 터미널이 아니라면 'not a tty'라는 메시지를 출력한다. 

사용예 
■ $ tty 
■ /dev/tty1 




umask 
파일을 생성할 때 현재 사용되고 있는 권한(permission)값의 마스크가 무엇인지 알려주거나 그것을 새로 지정할 때 사용된다. 

문법 
■ umask [ 마스크 ] 

설명 
아무런 인수없이 사용하면 파일 생성시 사용되고 있는 디폴트 마스크가 무엇인지 알려준다. 마스크를 지정하면 원하는 값을 지정할 수 있다. 

마스크 값은 세 자리의 8진법 숫자로 구성된다. 이것을 마스크라고 부르는 이유는 마스크 값의 각 비트가 들어오는 값을 걸러내는 역할을 하기 때문이다. 즉 마스크 값이 0이면 권한 지정에 제한을 두지 않는다는 것이고 6이라면 읽기와 쓰기에 제한을 가한다는 의미가 되기 때문이다. 

사용예 
■ $ umask 033 
자신은 제한이 없지만 다른 사용자나 그룹은 쓰기와 실행을 할 수 없다. 




umount 
설정된 마운트 정보를 해제한다. 

문법 
■ umount 장치명 or 마운트포인트 
■ umount -a 
■ umount -t 파일시스템 형태 

옵션 
-a : 모든 파일 시스템의 마운트 정보를 해제한다. 
-t : 특정 형태의 파일 시스템만을 선택하여 해제된다. 옵션 뒤에는 어떤 파일 시스템을 해제할 것인지 지정한다. 

설명 
마운트되어 있는 장치와의 설정을 해제한다. /dev/hda3와 같은 이름이나 /dosc와 같은 포인트 이름을 사용한다. 파일 시스템 형태를 지정할 때는 msdos, minix, hpfs 등과 같은 이름을 사용한다. 마운트 해제시 사용중인 장치는 해제하지 못한다. 예를들어 /dosc 디렉토리에 위치한 상태에서 도스파일 시스템과의 마운트를 해제하지는 못한다. 

사용예 
■ $ umount /dev/hda1 




uname 
시스템 이름과 다른 정보를 보여준다. 

문법 
■ uname [ -snvma ] 

옵션 
-s : 시스템 이름을 알려준다. 
-n : 시스템의 노드(node) 이름을 알려준다. 
-r : 오퍼레이팅 시스템의 증명번호를 알려준다. 
-v : 오퍼레이팅 시스템의 버전(version) 번호를 알려준다. 
-m : 하드웨어의 이름을 알려준다. 
-a : 모든 정보를 알려준다. -snrvm 과 같다. 

설명 
-s 옵션은 기본값으로 내장되어 있다. 옵션이 없다면 시스템 이름을 알려준다. 

사용예 
■ $ uname -sm 




uncompress 
compress로 압축되어 있는 파일의 압축을 푼다. 

문법 
■ uncompress 파일명(들) 

설명 
사실상, compress의 -d 옵션을 사용하면 압축을 풀 수 있기 때문에 이 명령은 불필요하다. 하지만 옵션을 사용하는 것보다 의미있는 단어를 사용함으로 좀더 친숙하게 사용할 수 있다. uncompress는 자신이 압축 풀기 동작을 수행하는 것이 아니라 -d 옵션을 주어 compress를 호출한다. uncompress 자신의 파일 크기는 아주 적다. 

사용예 
■ $ uncompress blade.Z 





user 
여러 명의 사용자가 동시에 유닉스 시스템에 로그인하여 사용하고 있을 때 어떤 사람들이 시스템에 접속해 있는지를 알아야 할 필요가 있다. 이때 간단히 사용자들의 id 이름만을 알고자 한다면 users 명령을 사용하면 된다. 

문법 
■ users 

설명 
이 명령은 아무런 옵션이 없다. 시스템이 네트워크에 연결되어 있다면 이 명령은 모든 네트워크 상에서 작업하는 사용자들을 보여주지는 못한다. 단지 그 명령이 사용되는 지역 호스트 상의 사용자들을 보여줄 수 있다. 

사용예 
■ $ users 
■ sisap blade 




uudecodeuuencode 

uuencode는 USENET과 같이 ASC2 코드만을 다루는 미디어를 위해 바이너리 코드를 변환한다. uudecode는 그 반대의 동작을 수행한다. 

문법 
■ uudecode [파일명] 
■ uuencode [파일명] 이름 

설명 
기본적으로 표준 입력으로 읽거나 쓴다. uuencode는 디코딩되었을 때 사용될 파일의 이름도 함께 명시한다. e-mail 이나 USENET 은 바이너리 코드를 사용하지 않기 때문에 이 작업으로 바이너리 파일을 보내고 받을 수 있다. 

사용예 
■ $ uuencode canexe.Z canexe.Z > exemail.uu 
canexe.Z 라는 파일을 인코딩 작업을 거친 후 exemail.uu라는 파일로 저장한다. 이 파일을 디코딩하면 canexe.Z라는 이름으로 파일이 만들어진다. 



vi 
거의 유닉스 표준이라고 말할 수 있는 풀 스크린 에디터이다. 이것은 유닉스 시스템의 일부라고 말할 수 있으므로 레퍼런스에 포함했다. 

문법 
■ vi [ 파일명(들) ] 

설명 
이것은 매우 강력한 기능의 스크린 에디터이다. 메뉴 방식이 아니라 명령 입력 방식이기 때문에 처음 학습이 불편하다는 단점이 있지만 사용법을 알면 매우 빠르게 작업을 수행할 수 있다. vi대한 자세한 내용은 이 책의 앞부분이나 다른 참고 서적을 참조하라. 

사용예 
■ $ vi manual.book ;; vi를 실행 후 manual.book을 읽어들인다. 




w 
현재 시스템에 접속한 사용자들의 정보를 출력한다. 

문법 
■ w [ 사용자 ] 

설명 
이것은 who 명령과 유사한 동작을 한다. 인수로 사용자 ID를 지정한다면 특정 사용자에 대한 정보를 얻을 수 있으며, 인수없이 사용된다면 현재 시스템에 접속한 모든 사용자들의 정보를 자세히 출력한다. 출력 내용의 첫줄에는 시스템 가동 현황을 보여준다. 

사용예 
■ $ w 
■ 11: 32 am up 4 min, 2 users, load average : 0.00, 0.05, 0.02 
■ User tty From login@ idle JCPU PCPU what 
■ root tty1 11:28am w 
■ blade tty2 11:31am -sh 







wall 
현재 시스템에 로그온되어 있는 모든 사용자들에게 메시지를 보낸다. 

문법 
■ wall [ 파일명 ] 

설명 
메시지는 각 사용자의 터미널에 나타나게 된다. 인수로 파일 이름이 주어지지 않으면 표준 입력으로부터 데이터를 받아들이며, ^D로 입력을 종결하고 메시지를 발송한다. 이것을 사용하려면 슈퍼 유저로 로그인되어야 한다. 사용자가 자신의 터미널을 메시지 수신 거부 상태로 만들어 놓더라도 슈퍼 유저는 그것을 무시할 수 있다. 

사용예 
■ $ wall 
30 minutes latter, this system will be halted!! ^D 




wc 
파일내의 단어 수 등의 정보를 출력한다. 

문법 
■ wc [ -cwl ] 파일이름(들) 

옵션 
-c : 문자(character)의 개수만을 알고 싶을 때 사용한다. 
-w : 단어(word)의 개수만을 알고 싶을 대 사용한다. 
-I : 행(line)의 숫자를 알고 싶을 때 사용한다. 혹은 개행 문자의 개수를 알고자 할 때 사용될 수도 있다.

