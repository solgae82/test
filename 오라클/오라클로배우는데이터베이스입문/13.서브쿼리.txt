메인쿼리와 서브쿼리로 구분하자
예를 들어 이런 형식이다
	select ename, sal from emp /* 메인 쿼리 */
	where sal > (select sal from emp where ename='JONES') /* (중첩) 서브쿼리 */

특징
	- 연산자와 같은 비교 또는 조회대상의 오른쪽에 놓이며 괄호()로 묶어서 사용
	- 특수한 몇몇 경우를 제외한 대부분의 서브쿼리에는 order by 절을 사용할 수 없다.
	- 메인쿼리 (열,자료형)과 열갯수와 맞춰서 서브쿼리 열을 지정해야 한다.
	- 연산자가 특정한 자료형과 1개의 자료만 필요할때 대입되는 서브쿼리도 같은 자료형과 단 1개의 행만 출력해야한다

구분
	단일행 서브쿼리, 다중행 서브쿼리로 나뉜다.

단일행 서브쿼리
	select * from emp e , dept d
	where e.deptno = d.deptno
	and e.sal > (select avg(sal) from emp);

다중행 서브쿼리와 연산자
	IN : 메인 쿼리의의 데이터가 서브쿼리의 결과 중 하나라도 일치한 데이터가 있다면 true.
	ANY,SOME : 메인 쿼리의 조건식을 만족하는 서브쿼리의 결과가 하나 이상이면 true.
	ALL : 메인쿼리 조건식을 서브쿼리의 결과가 모두 만족해야 true.
	EXISTS : 서브쿼리의 결과가 존재하면 (행이 1개이상이면) true.


	IN 연산자
		select * from emp
		where sal in(
		    select max(sal)
		    from emp
		    group by deptno);

	ANY, SOME 연산자(둘은 이름만 다른 같은 연산자)
		- ANY 또는 SOME (조건들..) 중 만족하는 값 하나만 있으면 true.
		- '=' 연산을 하면 IN(..) 과 같다
		
		1000 = ANY (500, 1000, 2000) : ANY값에  열값과 같은 1000이 있으므로 True. 
			- sal = ANY(500, 1000, 2000)으로 생각해보면,
			ANY(500, 1000, 2000) 값 중 일치하는 sal 값 행 모두 출력
		
		1000 > ANY (500, 1000, 2000) : ANY값에 열값인 1000 보다 작은 500이 있으므로 true.
			- sal > ANY(500, 1000, 2000)로 생각해보면, 
			ANY(..)값 중 제일 작은 값인 500 보다 큰 sal 값 행 모두 출력
		
		2000 < ANY (500, 1000, 2000) : ANY값에 열값인 2000 보다 큰 값이 없으므로 false.
			- sal < ANY(500, 1000, 2000)로 생각해보면, 
			ANY(..)값 중 제일 큰 값인 2000 보다 작은 sal 값 행 모두 출력
			
		------------- 예제
		
		select sal from emp where deptno=30
		: 서브쿼리 결과(1600,1250,1250,2850,1500,950)

		select * from emp 
		where sal < some(select sal from emp where deptno=30)
		: sal값이 서브쿼리 결과 가장 큰 값인 2850 보다 작은 행 모두 출력 
		
		select * from emp
		where sal > any(select sal from emp where deptno=30)
		: sal값이 서브쿼리 결과 가장 큰 작은 값인 950 보다 큰 행 모두 출력
		
	
	ALL 연산자
		- 서브쿼리의 모든 결과가 조건식에 맞아 떨어져야만 true
		
		select * from emp 
		where sal < all(select sal from emp where deptno = 30);
		: 서브쿼리 결과(1600,1250,1250,2850,1500,950) 값들보다 작은 값, 
		가장 작은 값이 950보다 작은 조건열의 행이 출력된다.
		
		select * from emp 
		where sal > all(select sal from emp where deptno = 30);
		: 서브쿼리 결과(1600,1250,1250,2850,1500,950) 값들보다 큰 값, 
		가장 큰 값인 2850보다 큰 조건열의 행이 출력된다.

	EXISTS 연산자
		all or nothing
		서브쿼리 결과가 한개라도 있으면 메인 쿼리 모두 출력, 없으면 출력 안함
		만족하는 데이터가 있는지 없는지 검색할때 주로 사용된다.
		
		예를 들어 count(*)로 존재여부를 체크하기 보단 이 방식이 효율이 더 좋다.
		존재하면 바로 true 후 더 이상 세지 않고 반환 하는 듯..	
		
			select * from emp 
			where exists(select dname from dept where deptno=50);

		deptno=50 가 없으므로 아무것도 출력되지 않는다.

		실무에서는 아래와 같은 형식을 많이 쓴다
		데이터 존재여부만 빠르게 판단해야 경우에 주로 쓰인다.
			
			/* 많이 쓰이는 데이터 존재여부 체크 쿼리 : 외워라 */
			
			select 1 as cnt from dual 
			where exists(select dname from dept where deptno=50 );

		서브쿼리 결과가 존재하면 1을 반환하고, 메인쿼리에서는 cnt 별칭의 1을 반환한다.
		없으면 아무것도 반환하지 않는다. 
		(속도 또한 존재 데이터 모두를 count 하는 방식이 아니므로 데이터가 많을 경우는 이 방식이 유리하다)

다중열 서브쿼리	
	비교조건이 2개 이상인 서브쿼리
	
		select * from emp 
		where
		    (deptno , sal) in (select deptno , max(sal) 
					from emp
					group by deptno); 
					
	서브쿼리 결과로 나온 행의 deptno , sal 의 값과 일치하는 것만  true.
	각 결과 열의 값과 and연산으로 일치하는 행 (deptno=값 and sal=값)만 true.
	
인라인 뷰(inline view)	
	from 절에 사용하는 서브쿼리

		select * 
		from
		    (select * from emp where deptno=10) e10 , 
		    (select * from dept) d
		where
		    e10.deptno = d.deptno;

중첩 서브쿼리
	WHERE절에 사용하는 서브쿼리
	
	(단일행 중첩 서브쿼리)
	select * from dept a 
	where a.deptno = (select b.deptno from emp b where b.ename='SCOTT');
	
	(다중행 중첩 서브쿼리)
	select * from emp 
		where
		    (deptno , sal) in (select deptno , max(sal) 
					from emp
					group by deptno);
	
상관 서브쿼리 (correlated subquery)
	메인 쿼리의 컬럼 값을 서브 쿼리에서 참조하는 서브쿼리의 한 종류. 
	특히, 세미 조인(Semi Join)에서 자주 사용됩니다. 
	메인 쿼리의 각 행마다 서브쿼리가 실행된다
	그러므로 성능저하의 가능성이 높다
	 		
		/* 메인쿼리 e1을 서브쿼리에서 조건식으로 쓰고 있다. 
		같은 테이블을 다시 조인 연산하는 형태
		!!성능저하 쿼리이다
		*/
		select * from emp e1 
		where sal > (select min(sal) from emp e2 
			    where e1.deptno = e2.deptno)
		order by deptno , sal;

세미조인 (semi-join)
	세미 조인은 서브쿼리를 사용하여 메인 쿼리와 연결하는 조인 방식 중 하나.
	주로 IN이나 EXISTS 연산자를 사용하여 구현되며, 
	서브쿼리에 존재하는 데이터만 메인 쿼리에서 추출하는 역할을 한다.
	
	크게 보면 두가지 구현 방식이 있다
		
	1) 서브쿼리가 먼저 실행되어 결과 집합을 만든 후 메인쿼리 데이터를 필터링하는 방식.
		
		SELECT * FROM 학생
		WHERE 학번 IN (
		SELECT 학번 FROM 수강 WHERE 과목명 = '데이터베이스');
	
	2) 메인쿼리가 먼저 실행되어 나온 결과 집합을 [상관 서브쿼리]로 연결하여 메인쿼리 결과 행마다 비교 필터링.
	
		select * from dept a 
		where exists(
		    select 1 from emp b
		    where a.deptno = b.deptno 
		    and 
		    b.hiredate >= to_date('1987-01-01','YYYY-MM-DD')
		);
			
	IN(), EXISTS()의 실행 순서:
		- IN() 실행순서는 IN() 쿼리 -> 메인쿼리
		- EXISTS() 실행순서는 메인쿼리 -> EXISTS()쿼리
	
(헷갈리는) 상관 서브쿼리와 세미 조인의 구분

	상관 서브쿼리는 메인 쿼리의 컬럼 값을 서브 쿼리에서 참조하는 서브쿼리의 한 종류입니다. 특히, 세미 조인(Semi Join)에서 자주 사용됩니다. 
	
	세미 조인은 서브 쿼리의 결과에 존재하는 데이터만 메인 쿼리에서 추출하는 방식으로, IN 또는 EXISTS 연산자와 함께 사용될 때 상관 서브쿼리가 활용됩니다. 
	
	상관 서브쿼리와 세미 조인의 관계:
	
		세미 조인:
			서브 쿼리의 결과 집합을 기반으로 메인 쿼리의 데이터를 필터링하는 조인 방식.		
		
		상관 서브쿼리:
			서브 쿼리 내에서 메인 쿼리의 컬럼 값을 참조하는 서브쿼리.
		
		관계:
			세미 조인에서 메인 쿼리와 서브 쿼리 간의 데이터 연관성을 정의할 때, 상관 서브쿼리가 자주 사용됩니다

	※ 요약: 
		세미 조인 : 메인쿼리 결과를 서브쿼리로 조인해서 필터링 하는 방식
		상관 서브쿼리 : 서브쿼리내에 메인 쿼리 컬럼값 참조하는 서브쿼리 방식		
스칼라 서브쿼리(scalar subquery)	
	select 절의 컬럼 자리에 쓸 수 있는 서브쿼리
	반드시 1개의 결과만 나와야 한다..꼭!

		select e.* 
		, (select max(sal) from emp where deptno= e.deptno) as dept_max
		from emp e;
		
with 절
	서브쿼리별로 별칭을 미리 지정해 놓고 쓸 수 있는 방식
	with 별칭 as 서브쿼리 ..

		with
			e10 as (select * from emp where deptno=10)
		    ,   d as (select * from dept)
		select * 
		from e10, d
		where e10.deptno = d.deptno;
