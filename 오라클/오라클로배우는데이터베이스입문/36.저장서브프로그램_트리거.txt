저장 서브프로그램 :
	- 오라클 시스템에 저장하여 사용하는 PL/SQL 프로그램
	- 프로시저,함수,패키지,트리거 등
 
트리거: 특정이벤트 발생시 자동으로 수행할 기능

-------------------

set SERVEROUTPUT on;

-- DML 실행 전 수행할 트리거 테스트 

	-- 트리거 테스트 테이블 생성
	create table emp_trg
	as select * from emp;

	-- DML 실행 전 수행할 트리거 생성
	/*
	- INSERTING , UPDATING , DELETING 은 예약 키워드 , 이벤트가 발생했을때 true.
	- raise_application_error 는 내장 프로시저로서 사용자 정의 예외 발생
	    -(사용자 정의 예외코드는 20000 ~ 20999 까지 사용가능)
	*/
	create or replace trigger trg_emp_nodml_weekend 
	before --실행전
	insert or update or delete on emp_trg
	begin
	    if to_char(sysdate , 'DY') in ( '토', '일') then 
		if INSERTING then --삽입할때
		    raise_application_error(-20000, '주말 사원정보 추가 불가');
		elsif UPDATING then -- 수정시
		    raise_application_error(-20001, '주말 사원정보 수정 불가');
		elsif DELETING then -- 삭제시
		    raise_application_error(-20002, '주말 사원정보 삭제 불가');
		else
		    raise_application_error(-20003, '주말 사원정보 변경 불가');
		end if;
	    end if;
	end;
	/

	-- update 트리거 이벤트 발생하기, oracle 설치된 OS 날짜를 토요일로 변경하고 테스트
	update emp_trg set sal=3500 where empno = 7788; -- ORA-20001: 주말 사원정보 수정 불가

-- DML 수행 후 수행할 트리거 테스트

	-- 로그 테이블 생성
	create table emp_trg_log(
	    tablename varchar2(10), -- DML이 수행된 테이블 이름
	    dml_type varchar2(10),  -- DML 명령어 종류
	    empno number(4),        -- DML 대상이 된 사원번호
	    user_name varchar(30),  -- DML 수행할 user 이름(세션이름)
	    change_date date        -- DML 수행된 날짜
	);

	-- 대상테이블에 DML 수행 후 변경 사항 이력 emp_trg_log 테이블에 기록하기 트리거 생성
	create or replace trigger trg_emp_log 
	after -- 수행 후
	insert or update or delete on emp_trg
	for each row --영향 받은 행마다 트리거 실행

	begin
	    
		if INSERTING then
		    insert into emp_trg_log values(
			'emp_trg','INSERT', :new.empno,
			SYS_CONTEXT('USERENV','SESSION_USER'), sysdate
		    );
		elsif UPDATING then
		    insert into emp_trg_log values(
			'emp_trg','UPDATE', :old.empno,
			SYS_CONTEXT('USERENV','SESSION_USER'), sysdate
		    );
		elsif DELETING then
		    insert into emp_trg_log values(
			'emp_trg','DELETE', :old.empno,
			SYS_CONTEXT('USERENV','SESSION_USER'), sysdate
		    );
		
		end if;
	    
	end;
	/

	-- 삽입 이벤트 트리거 발생하기
	insert into emp_trg values(9999,'DONG','CLERK',7788,to_date('2025-12-25','YYYY-MM-DD')
	,1200, null, 20);

	commit;

	-- 삽입 확인
	select * from emp_trg;

	-- 트리거 로그 확인
	select * from emp_trg_log;

		/* 
		tablename   dml_type    empno   user_name   change_date
		-------------------------------------------------------
		emp_trg	    INSERT	    9999    DONG        25/12/25
		*/

	-- 업데이트 이벤트 트리거 발생하기
	update emp_trg set sal = 1300 where mgr=7788; -- 2개 행 이(가) 업데이트되었습니다.
	commit;
	
	-- 업데이트 확인
	select * from emp_trg; -- '7876/ADAMS', '9999/DONG' 2개행이 sal=1300 으로 변경되었다

	-- 트리거 로그 확인
	select * from emp_trg_log;

		/* 
		tablename   dml_type    empno   user_name   change_date
		-------------------------------------------------------
		emp_trg	    INSERT	    9999	DONG	    25/12/25
		emp_trg	    UPDATE	    7876	DONG	    25/12/25
		emp_trg	    UPDATE	    9999	DONG	    25/12/25
		*/

--트리거 정보 조회 (user_triggers)
	select * from user_triggers;
	
	select 
	    trigger_name, 
	    trigger_type,
	    triggering_event,
	    table_name,
	    status  /* ENABLED/DISABLED */
	from user_triggers;

-- 트리거 변경
    --특정 트리거 (활성화/비활성화)
    alter trigger trg_emp_log disable; -- enable / disable

    -- 테이블 기준으로 관련된 트리거 모두 (활성화/비활성화)
    alter table emp_trg disable ALL TRIGGERS;

-- 트리거 삭제
	drop trigger TRG_EMP_LOG;
	
	
-------------------------------------------------// 최종 정리
트리거 DDL:  
	CREATE [OR REPLACE] TRIGGER trigger_name
	[BEFORE | AFTER | INSTEAD OF] 
	[INSERT | UPDATE | DELETE] ON table_name
	[REFERENCING OLD as od NEW as nw] -- (옵션)  
	[FOR EACH ROW] -- (옵션)
	[WHEN (condition)] -- (옵션)
	[FOLLOWS 트리거 이름, 트리거이름..] -- (옵션)
	[ENABLE | DISABLE] -- (옵션)
	
	DECLARE 
		-- (선언부 - 변수 등)

	BEGIN 
		-- (실행부 - PL/SQL 코드)
		EXCEPTION -- (예외 처리 - 선택적)
	END;
	/
	
속성 설명:
	
	[BEFORE | AFTER | INSTEAD OF]
		BEFORE : 이벤트 발생 전 트리거 실행
		AFTER : 이벤트 발생 후 트리거 실행
		INSTEAD OF : view에 대해 DML실행할 경우 DML 대신 트리거를 실행
		
	[INSERT | UPDATE | DELETE]
		- 트리거가 실행될 DML 이벤트 지정
		- 'OR' 로 다중 설정 가능
			insert OR update OR delete on EMP
		- 'OF' 로 컬럼 지정 가능
			update OF sal, comm on EMP -- EMP.sal 컬럼이 변경될 때
			
	ON table_name : 이벤트가 발생하는 대상 테이블 지정 (예: ON EMP)

	[REFERENCING OLD as od NEW as nw]
		- 지정하지 않으면 레코드 잠조명은 아래와 같다
			- 변경 전 레코드 참조명은 OLD
			- 변경 후 레코드 참조명은 NEW
		- 특별히 별칭을 지정해서 사용하고 싶다면 아래와 같이 한다
			
			REFERENCING OLD before_rec
			REFERENCING NEW as after_rec
			
			또는 아래처럼 한번에 모두 설정
				
			REFERENCING OLD before_rec od NEW as after_rec
		- 설정 후 PL/SQL 안에서 사용
			:before_rec.sal -- 변경 전 레코드 sal 컬럼 접근
			:after_rec.sql  -- 변경 후 레코드 sal 컬럼 접근

		※ 특별한 이유가 없다면 그냥 :NEW , :OLD 를 사용하는게 낫다
		
	[FOR EACH ROW]	

		- FOR EACH ROW: (row 단위 트리거)
			- 각 행마다 트리거 실행
			- FOR EACH ROW 트리거는 DML(INSERT, UPDATE, DELETE) 이벤트 발생 시 
			영향받는 각 행(row)마다 트리거가 실행되도록 하는 옵션.
		
		- FOR EACH STATEMENT: (문장 단위 트리거)
			- 전체 DML 문장에 대해 1번만 실행 
			(아무 것도 지정하지 않으면 이 모드가 지정된 것으로 간주)
	 
	[WHEN (condition)]
			
		- 역할: FOR EACH ROW 트리거가 실행된 후, 트리거 본문 실행 여부를 결정하는 필터 역할을 합니다.
		- 구문: WHEN (조건식) 형태로 사용하며, 조건식은 old (변경 전) 또는 new (변경 후) 레코드 컬럼을 참조하여 작성합니다.
		- 예시: WHEN (new.salary > 10000)과 같이 급여가 10000을 초과하는 경우에만 트리거 본문이 실행되도록 합니다

		(예시)
			CREATE OR REPLACE TRIGGER trg_update_salary
			BEFORE UPDATE ON emp
			FOR EACH ROW
			WHEN (NEW.sal > 10000) -- 업데이트된 NEW.sal 값이 10000을 넘을때만 실행 
			BEGIN
			    DBMS_OUTPUT.PUT_LINE('높은 급여 변경 발견 => ' || :NEW.sal);
			END;
			/
		
		-주의 할 점은 WHEN 절의 NEW 레코드 참조변수는 ':'을 붙이지 않는다.
		-트리거 본체에서는 ':NEW' 처럼 사용해야 한다.
		
	[FOLLOWS 트리거 이름, 트리거이름..]
		- 오라클 11g 이상에서 설정 가능
		
		FOLLOWS trg_A -- 현재 트리거 보다 먼저 실행될 트리거(trg_A) 설정.
		
	[ENABLE | DISABLE]
		- 오라클 11g 이상에서 설정 가능
		- 활성화/비활성화를 트리거 만들면서 정하는 기능(쓸일 없을 듯)
		
	
트리거 제약사항
	1. 트리거 소스코드 크기는 32KB 이하로 해야한다.
	2. LONG, LONG RAW 타입 변수 사용 못함
	3. 트리거가 걸린 테이블을 조회하거나 변경하는 로직을 사용할 수 없다.
	4. 트리거 내에서 DDL,TCL실행 불가능(기본)
		- 꼭 사용해야한다면 declare절에 PRAGMA AUTONOMOUS_TRASACTION 설정해야 한다
		declare
		
			PRAGMA AUTONOMOUS_TRASACTION	
			
		begin..end;
	5. 트리거 내에서 트랜잭션 제어하는 서브프로그램은 호출 못한다.
		

