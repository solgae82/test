스프링부트 의존성 관리

	- 스타터 (starter)
		: 스프링이 제공하는 특정 모듈을 관련된 라이브러리 의존성을 해결해 주는 기술
	- 자동설정 (AutoConfiguration)
		: 스타터를 통해 추가한 모듈을 사용하기 위한 빈 설정등을 자동으로 처리해주는 기술 
	- 액추에이터 (Actuator)
		: 스프링 부트로 개발된 시스템을 모니터링할 수 있는 다양한 기능 제공
	

스타터 이해하기

	: 스타터는 관련된 라이브러리들을 마치 패키지처럼 제공해준다
	: 스타터를 pom.xml에 추가하면 관련 라이브러리들이 자동으로 한 셋트로 maven에 추가된다.
	: 스타터 메이븐 이름은 'spring-boot-starter-모듈명' 형식을 가진다
	: 메이븐의 <parent /> 태그가 starter를 가능하게 해주는 태그이다.
	
		(예)
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
	
	
	- pom.xml <parent />구조 , 스프링 부트 기본 라이브러리 상속구조
	
		1. 프로젝트 pom.xml <parent />
		
			<parent>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-parent</artifactId>
				<version>3.5.3</version>
				<relativePath/> <!-- lookup parent from repository -->
			</parent>
			
			: spring-boot-starter-parent-3.5.3.RELEASE.pom 을 상속하고 있다
			
		2. spring-boot-starter-parent-3.5.3.RELEASE.pom 의 <parent />
			<parent>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-dependencies</artifactId>
				<version>3.5.3</version>
			</parent>
		
			: spring-boot-dependencies-3.5.3.RELEASE.pom 을 상속하고 있다 
			: plugin 설정만 잔뜩있다
			
		3. spring-boot-dependencies-3.5.3.RELEASE.pom
			- properties
			- dependencies
			
			: 비로소 스프링 부트 버전(3.5.3) 버전이 쓰는 라이브러리들 모음인 최상위 pom.xml에 왔다. 
			: 스프링 부트 버전(3.5.3)에서 쓰는 dependencies , starter , 프로퍼티등을 확인할 수 있다
		
	스타터 재정의하기
		:pom.xml <!-- 버전 3.5.3 에서 3.4.3 낮추기 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<version>3.4.3</version> <!-- 추가 -->
		</dependency>
		
		:maven Dependencies : spring-boot-starter-web-3.4.3.jar 로 변경됨
		
	프로퍼티 재정의 하기
		:pom.xml spring-boot-starter-web 스타터 내부 중 스프링 버전만 바꾸고 싶을때..
		..
		<properties>
			<java.version>17</java.version>
			<spring.version>6.1.0.RELEASE</spring.version> <!-- 요기 -->
		</properties>
	
		:설정해도 아무 변화가 없더라. 전에는 되었던 거 같은데.. 암튼 이런 식이라는 것. 
	
자동설정 이해
	: 실행시 수많은 빈들이 자동 등록되는데 자동설정 어노테이션을 분석해보면 된다.
	@SpringBootApplication : 플젝Application.java 의 이 어노테이션을 ctrl + 클릭으로 들어가보면..
				아래와 같다
			
	SpringBootApplication.class 
	..
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Inherited
	@SpringBootConfiguration
	@EnableAutoConfiguration
	@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
			@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
	public @interface SpringBootApplication {..}
	
	: 이 중 중요한 어노테이션은  @SpringBootConfiguration , @EnableAutoConfiguration , @ComponentScan
	
	@SpringBootConfiguration : @Configuration와 같다, 환경설정 클래스라는 뜻
	
	@ComponentScan : 
		- @Configuration,@Controller,@Service,@Repositary,@RestController등이 붙은 
			개발자가 만든 클래스들 객체를 메모리에 올리는 역할, [사용자 빈 등록]
		
	@EnableAutoConfiguration : 미리 준비되어 있어야할 컴포넌트들, 예를 들어 업로드리졸버 같은 객체들을 
		자동 설정하는 어노테이션 , [자동 설정 빈 등록]
		
		: 수많은 빈 설정 클래스 중에 WebMvcAutoConfiguration.class 를 분석해보자
		pring-boot-autoconfigure-3.5.3.jar
			META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
			
			: org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
			가 자동 설정되는 것을 알 수 있다.
			
		WebMvcAutoConfiguration.class
		
			@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
					ValidationAutoConfiguration.class })
			@ConditionalOnWebApplication(type = Type.SERVLET)
			@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
			@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
			@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
			@ImportRuntimeHints(WebResourcesRuntimeHints.class)
			public class WebMvcAutoConfiguration {..}
			
	: 빈 등록 순서
		@ComponentScan -> @EnableAutoConfiguration
	
사용자 정의 스타터 

	자동설정 구현 (maven install)
	
		1. 새로운 프로젝트 생성 (spring-boot-starter-dong)
		
		2. pom.xml
			<!-- custom -->
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-autoconfigure</artifactId>
			</dependency>
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-autoconfigure-processor</artifactId>
				<optional>true</optional>
			</dependency>
		3. java 구현
			
			com.solgae.jdbc.config.BoardAutoConfiguration.java
				@Configuration
				public class BoardAutoConfiguration {
					@Bean
					public JDBCConnectionManager getJDBCConnectionManager() {
						JDBCConnectionManager manager = new JDBCConnectionManager();
						manager.setDriverClass("oracle.jdbc.driver.OracleDriver");
						manager.setUrl("jdbc:oracle:thin:@loclalhost:1521:xe");
						manager.setUserName("DONG");
						manager.setPassword("100you");
						return manager;
					}
				}
			com.solgae.jdbc.util.JDBCConnectionManager.java
				public class JDBCConnectionManager {
					private String driverClass;
					private String url;
					private String userName;
					private String password;
						..setter, getter, toString 등 구현
				}
				
		4. src/main/resources 디렉토리 내에 META-INF 만들고,
			spring.factories (파일만 생성, 내용없는)
			spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
				(아래 파일내용 추가)
				com.solgae.jdbc.config.BoardAutoConfiguration
		
		5. maven install 로 메이븐 리포지토리에 설치
	
	사용자 정의 스타터와 자동설정 사용하기
		
		1. 사용할 프로젝트 생성 : chapter02
		
		2. spring-boot-starter-dong 프로젝트 pom.xml에 있는 선언부 복사해서 현 플젝 pom.xml에 복사
			
			spring-boot-starter-dong : pom.xml
				..
				<groupId>com.solgae</groupId>
				  <artifactId>spring-boot-starter-dong</artifactId>
				  <version>0.0.1-SNAPSHOT</version>
				..
			
			chapter02 : pom.xml
			
				<!-- 커스텀 스타터-->
				<dependency>
					<groupId>com.solgae</groupId>
					<artifactId>spring-boot-starter-dong</artifactId>
					<version>0.0.1-SNAPSHOT</version>
				</dependency>
		
			: 추가 후 현 플젝 Maven Dependencies에 추가 확인
			
			
		3. 실행시 메모리에 올려지는 com.solgae.jdbc.util.JDBCConnectionManager를 
		불러오는 코드 (JDBCConnectionManagerRunner)를 작성후 실행해 본다
			
			import com.solgae.jdbc.util.JDBCConnectionManager; //install 된

			@Service
			public class JDBCConnectionManagerRunner implements ApplicationRunner {

				@Autowired
				private JDBCConnectionManager connectionManager; //메모리에 올라온 객체 주입
		
				@Override
				public void run(ApplicationArguments args) throws Exception {
					// TODO Auto-generated method stub
					System.out.println("커넥션 매니저: " +  connectionManager.toString());
					/*
					커넥션 매니저: JDBCConnectionManager 
					[driverClass=oracle.jdbc.driver.OracleDriver, 
					url=jdbc:oracle:thin:@loclalhost:1521:xe, 
					userName=DONG, 
					password=100you]
					*/
				}

			}
			
	자동설정 재정의 
			
		1. 현 플젝에 빈 중복 등록시 덮어쓰기 가능하게 하는 설정 추가
			- 현 플젝 application.properties 에 추가
				spring.main.allow-bean-definition-overriding=true
		
		2. 외부 spring-boot-starter-dong 플젝의 com.solgae.jdbc.config.BoardAutoConfiguration.java 변경
			
			- @Bean 설정에 @ConditionalOnMissingBean 추가				
				..
				@Bean
				@ConditionalOnMissingBean  //<= 추가
				public JDBCConnectionManager getJDBCConnectionManager() {..}
				
			: 중복 빈이 없을때 현재 빈을 추가한다는 조건 설정 어노테이션
			
		3. spring-boot-starter-dong 다시 maven install 
		
		4. 현 플젝에 새 빈 등록 클래스 추가 후 테스트 
			
			import com.solgae.jdbc.util.JDBCConnectionManager; // 새 등록 외부 중복 객체

			@Configuration
			public class BoardConfiguration {

				@Bean
				public JDBCConnectionManager getJDBCConnectionManager() {
					JDBCConnectionManager manager = new JDBCConnectionManager();
					
					manager.setDriverClass("org.h2.Driver");
					manager.setUrl("jdbc:h2:tcp://localhost/~/test");
					manager.setUserName("sa");
					manager.setPassword("h2");
					return manager;
					
				}
			}
			
		5. 다시 테스트 JDBCConnectionManagerRunner 로그 확인, 새 등록된 빈 출력이 검증된다.
		
			커넥션 매니저: JDBCConnectionManager [
			driverClass=org.h2.Driver, 
			url=jdbc:h2:tcp://localhost/~/test, 
			userName=sa, password=h2]
			
		: 플젝에서 설정한 빈으로 대체되는 것이 확인된다.
		
	
	프로퍼티로 설정하기
		
		1. spring-boot-starter-dong 스타터 pom.xml에 자동구성 프로세서(프로퍼티 값 연결) 라이브러리 추가
			<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-autoconfigure-processor</artifactId>
				<optional>true</optional>
			</dependency>
			
		2. 현 플젝 application.properties 에 추가
			board.jdbc.driverClass=org.h2.Driver
			board.jdbc.url=jdbc:h2:tcp://localhost/~/test
			board.jdbc.userName=sa
			board.jdbc.password=h2
			
		3. spring-boot-starter-dong 스타터에 프로퍼티 파일 값 매칭 시키는 
			JDBCConnectionManagerProperties.java 생성
		
			@ConfigurationProperties(prefix = "board.jdbc") //<= 요기 중요
			public class JDBCConnectionManagerProperties {
				
				private String driverClass;
				private String url;
				private String userName;
				private String password;
				..getter, setter
			}
			
		4. spring-boot-starter-dong 스타터 BoardAutoConfiguration.java 에
			프로퍼티 파일 값 담긴 클래스 객체인 JDBCConnectionManagerProperties 추가연결 
			및 setting 변경
		
			@Configuration
			@EnableConfigurationProperties(JDBCConnectionManagerProperties.class) <=요기 추가
			public class BoardAutoConfiguration {

				@Autowired <=요기 추가
				private JDBCConnectionManagerProperties properties; <=요기 추가
				
				@Bean
				@ConditionalOnMissingBean
				public JDBCConnectionManager getJDBCConnectionManager() {
					
					JDBCConnectionManager manager = new JDBCConnectionManager();
					
					/*
					manager.setDriverClass("oracle.jdbc.driver.OracleDriver");
					manager.setUrl("jdbc:oracle:thin:@loclalhost:1521:xe");
					manager.setUserName("DONG");
					manager.setPassword("100you");
					*/
					
					//프로퍼티 클래스에서 받아온 값으로 셋팅 후 Bean 생성 반환
					manager.setDriverClass(properties.getDriverClass());
					manager.setUrl(properties.getUrl());
					manager.setUserName(properties.getUserName());
					manager.setPassword(properties.getPassword());					
					
					return manager;
					
				}
			}
			
		5. 현 플젝 실행 후 로그 확인
		
			커넥션 매니저: JDBCConnectionManager [driverClass=org.h2.Driver, 
			url=jdbc:h2:tcp://localhost/~/test, userName=sa, password=h2]