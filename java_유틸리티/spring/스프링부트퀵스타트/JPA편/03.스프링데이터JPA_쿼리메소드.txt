스프링 데이터 JPA : 쿼리메소드 

Spring Data JPA에서 메소드 이름의 규칙만으로 자동으로 JPQL 쿼리를 생성해주는 기능. 
(메소드명으로 jpql 쿼리를 생성하는 기능)

Repositary 인터페이스에 메소드명을 선언하는데,
find, get, query 등의 키워드와 엔티티 필드명,조건 키워드등을 조합하여 메소드명을 만든다.

(예)
	findBy + 컬럼명 + 조건 키워드(Like, GreaterThan 등) + And/Or + 컬럼명 

메소드 이름의 조합의 경우의 수는 너무 많으므로 API 문서를 보면서 만들어야한다.

간단한 조회 시 매우 유용하지만 복잡한 쿼리에는 @Query 어노테이션을 사용한다.
	
------------------- application.properties

# DataSource Setting
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=

# JPA Setting
spring.jpa.hibernate.ddl-auto=update #create
spring.jpa.generate-ddl=false
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.format_sql=true

# Logging Setting
logging.level.org.hibernate=info

------------------- Board.java

package com.solgae.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Entity
public class Board {

	@Id
	@GeneratedValue
	private Long seq;
	private String title;
	private String writer;
	private String content;
	private LocalDateTime createDate;
	private Long cnt;
}

------------------- 리포지토리 설정

package com.solgae.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.CrudRepository;

import com.solgae.domain.Board;
import java.util.List;


public interface BoardRepositary extends CrudRepository<Board, Long>{
	
	//제목 쿼리 메소드 (똑같은 제목)
	List<Board> findByTitle(String title); 
	
	//글내용 검색어 포함 쿼리메소드
	List<Board> findByContentContaining(String searchKeyword);
	
	//제목 또는 글내용 검색어 포함
	List<Board> findByTitleContainingOrContentContaining(String title, String content);
	
	//제목 검색어 포함 내림차순 정렬 가져오기
	List<Board> findByTitleContainingOrderBySeqDesc(String title);
	
	//모든 쿼리메소드는 마지막 파라미터로 페이징 처리 Pageable 인터페이스를 사용할 수 있다.
	//List<Board> findByTitleContaining (String title, Pageable paging);
	
	//페이징 정보를 포함한 Page 객체로 리턴 받으면, 결과 객체 + page정보 를 얻을 수 있다.
	Page<Board> findByTitleContaining (String title, Pageable paging);
}

------------------- 테스트

package com.solgae.repositary;

import java.time.LocalDateTime;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.solgae.domain.Board;
import com.solgae.persistence.BoardRepositary;

@SpringBootTest
public class QueryMethodTest {

	@Autowired
	private BoardRepositary boardRepository;
	/*
	@BeforeEach
	public void dataPrepare() {
		for(int i=1; i <= 200; i++) {
			Board vo = new Board();
			vo.setTitle("테스트 제목" + i);
			vo.setWriter("테스터");
			vo.setContent("글내용: + "+i);
			vo.setCreateDate(LocalDateTime.now());
			vo.setCnt(0L);
			
			boardRepository.save(vo);
			
		}
	}
	*/
	@Test
	public void testFindByTitle() {
		List<Board> searchList = boardRepository.findByTitle("테스트 제목10");
		System.out.println("검색결과: title");
		for(Board board : searchList) {
			
			System.out.println(board.toString());
			
		}
	}
	
	@Test
	public void testFindByContentContaining() {
		List<Board> searchList = boardRepository.findByContentContaining("17");
		System.out.println("검색결과: content");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	
	@Test
	public void testFindByTitleContainingOrContentConataining() {
		List<Board> searchList= boardRepository.findByTitleContainingOrContentContaining("17", "17");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	
	@Test
	public void tesFindByTitleContainingOrderBySeqDescBoards() {
		List<Board> searchList = boardRepository.findByTitleContainingOrderBySeqDesc("17");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
		
	}
	
	/*
	@Test
	public void testFindByTitleContaining() {
		// Pageable paging = PageRequest.of(0, 5); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력
		Pageable paging = PageRequest.of(0, 5, Sort.Direction.DESC, "seq"); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력, 정렬은 seq desc
		List<Board> searchList = boardRepository.findByTitleContaining("제목", paging);
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	*/
	
	@Test
	public void testFindByTitleContaining2() {
		
		Pageable paging = PageRequest.of(39, 5, Sort.Direction.DESC, "seq"); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력, 정렬은 seq desc
		Page<Board> pageInfo = boardRepository.findByTitleContaining("제목", paging);
		
		System.out.println("현재페이지 번호 =>"+ pageInfo.getNumber()); // 0부터 시작함
		System.out.println("페이지 당 최대 게시물 갯수(상수값)=>" + pageInfo.getSize());
		System.out.println("현재 페이지 게시물 개수=>" + pageInfo.getNumberOfElements());
		System.out.println("페이지 전체 갯수=>" + pageInfo.getTotalPages());
		System.out.println("게시물 전체 갯수=>" + pageInfo.getTotalElements());
		
		
		if(pageInfo.previousPageable().isUnpaged()) {
			System.out.println("이전 페이지 객체=> 없다");
		}else {
			System.out.println("이전 페이지 객체=>" + pageInfo.previousPageable());
		}
		
		if(pageInfo.nextPageable().isUnpaged()){
			System.out.println("다음 페이지 객체 => 없다");
		}else {
			System.out.println("다음 페이지 객체 =>" + pageInfo.nextPageable());
		}
		
		System.out.println("이전 페이지 존재 여부 =>" + pageInfo.hasPrevious()); 
		System.out.println("다음 페이지 존재 여부=>" + pageInfo.hasNext());
		System.out.println("마지막 페이지 여부=>" + pageInfo.isLast());
		System.out.println("결과 존재여부=>" + pageInfo.hasContent());
		System.out.println("Sort 객체 정보=>" + pageInfo.getSort());
		
		/*
		 * 총 39( 40페이지 있음), 마지막 페이지 테스트
		 
		현재페이지 번호 =>39
		페이지 당 최대 게시물 갯수(상수값)=>5
		현재 페이지 게시물 개수=>5
		페이지 전체 갯수=>40
		게시물 전체 갯수=>200
		이전 페이지 객체=>Page request [number: 38, size 5, sort: seq: DESC]
		다음 페이지 객체 => 없다
		이전 페이지 존재 여부 =>true
		다음 페이지 존재 여부=>false
		마지막 페이지 여부=>true
		결과 존재여부=>true
		Sort 객체 정보=>seq: DESC
		 */
		
		List<Board> searchList = pageInfo.getContent(); //현재 페이지 결과 목록
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
}

-------------------
쿼리 메소드 조합 기본 규칙
	시작: find, get, read, query, count, delete 등으로 시작.
	컬럼명: 엔티티의 속성 이름을 정확히 사용 (예: Title, Price).
	연산자: And, Or 등으로 여러 조건을 연결하고, Like, GreaterThan, LessThan, Is, In 등 다양한 키워드를 조합하여 조건 추가

주요 조합 키워드
	And, Or: 여러 조건을 논리적으로 연결.
	Is / Equals: 값이 같은 경우 (대부분 생략 가능).
	Not: 값이 다른 경우.
	Like: 부분 일치 검색 (% 사용).
	StartingWith, EndingWith, Containing: Like의 특수한 형태.
	GreaterThan, LessThan, GreaterOrEqual, LessOrEqual: 크기 비교.
	Between: 범위 검색.
	IsNull, IsNotNull: null 여부 확인.
	In: 여러 값 중 하나와 일치. 


작성예)
	// 예시: 제목(title)이 'Spring'으로 시작하고(Like) 가격(price)이 10000보다 큰(GreaterThan) 게시글 조회
	List<Post> findByTitleLikeAndPriceGreaterThan(String title, int price);

	// 예시: 상태(status)가 'ACTIVE'이거나(Or) 생성일(createdDate)이 특정 날짜 이전인(Before) 사용자 조회
	List<User> findByStatusOrCreatedDateBefore(String status, LocalDate date);

	// 예시: 이름(name)이 같거나(Equals) 이메일(email)이 포함된(Containing) 사용자 조회
	List<User> findByNameEqualsOrEmailContaining(String name, String email);

언제 쿼리 메소드 조합이 유용한가?
	- 간단한 조건의 조회/수정/삭제 시.
	- 복잡하지 않은 여러 조건을 결합할 때.
	- 개발 생산성을 높이고 싶을 때. 

한계 및 대안
	매우 복잡한 조인(JOIN)이나 동적 쿼리가 필요한 경우 쿼리 메소드 이름만으로는 한계가 있음.
	이 경우 @Query 어노테이션을 사용해 직접 JPQL을 작성하거나 QueryDSL을 사용하는 것이 더 효율적. 
	
	