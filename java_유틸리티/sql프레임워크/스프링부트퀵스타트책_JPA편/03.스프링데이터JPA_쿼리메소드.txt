스프링 데이터 JPA : 쿼리메소드 

	Spring Data JPA에서 메소드 이름의 규칙만으로 자동으로 JPQL 쿼리를 생성해주는 기능으로, 
	개발자가 복잡한 SQL 작성 없이 findByUsername, countByEmail처럼 메소드 이름 규칙에 따라 
	데이터를 조회, 수정, 삭제할 수 있어 개발 생산성을 높여줍니다. 

	이는 find, get, query 등의 키워드와 엔티티 필드명을 조합하여 사용하며, 
	간단한 조회 시 매우 유용하지만 복잡한 쿼리에는 @Query 어노테이션을 사용하기도 합니다

------------------- application.properties

# DataSource Setting
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=

# JPA Setting
spring.jpa.hibernate.ddl-auto=update #create
spring.jpa.generate-ddl=false
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.format_sql=true

# Logging Setting
logging.level.org.hibernate=info

------------------- Board.java

package com.solgae.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Entity
public class Board {

	@Id
	@GeneratedValue
	private Long seq;
	private String title;
	private String writer;
	private String content;
	private LocalDateTime createDate;
	private Long cnt;
}

------------------- 리포지토리 설정

package com.solgae.persistence;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.CrudRepository;

import com.solgae.domain.Board;
import java.util.List;


public interface BoardRepositary extends CrudRepository<Board, Long>{
	
	//제목 쿼리 메소드 (똑같은 제목)
	List<Board> findByTitle(String title); 
	
	//글내용 검색어 포함 쿼리메소드
	List<Board> findByContentContaining(String searchKeyword);
	
	//제목 또는 글내용 검색어 포함
	List<Board> findByTitleContainingOrContentContaining(String title, String content);
	
	//제목 검색어 포함 내림차순 정렬 가져오기
	List<Board> findByTitleContainingOrderBySeqDesc(String title);
	
	//모든 쿼리메소드는 마지막 파라미터로 페이징 처리 Pageable 인터페이스를 사용할 수 있다.
	//List<Board> findByTitleContaining (String title, Pageable paging);
	
	//페이징 정보를 포함한 Page 객체로 리턴 받으면, 결과 객체 + page정보 를 얻을 수 있다.
	Page<Board> findByTitleContaining (String title, Pageable paging);
}

------------------- 테스트

package com.solgae.repositary;

import java.time.LocalDateTime;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import com.solgae.domain.Board;
import com.solgae.persistence.BoardRepositary;

@SpringBootTest
public class QueryMethodTest {

	@Autowired
	private BoardRepositary boardRepository;
	/*
	@BeforeEach
	public void dataPrepare() {
		for(int i=1; i <= 200; i++) {
			Board vo = new Board();
			vo.setTitle("테스트 제목" + i);
			vo.setWriter("테스터");
			vo.setContent("글내용: + "+i);
			vo.setCreateDate(LocalDateTime.now());
			vo.setCnt(0L);
			
			boardRepository.save(vo);
			
		}
	}
	*/
	@Test
	public void testFindByTitle() {
		List<Board> searchList = boardRepository.findByTitle("테스트 제목10");
		System.out.println("검색결과: title");
		for(Board board : searchList) {
			
			System.out.println(board.toString());
			
		}
	}
	
	@Test
	public void testFindByContentContaining() {
		List<Board> searchList = boardRepository.findByContentContaining("17");
		System.out.println("검색결과: content");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	
	@Test
	public void testFindByTitleContainingOrContentConataining() {
		List<Board> searchList= boardRepository.findByTitleContainingOrContentContaining("17", "17");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	
	@Test
	public void tesFindByTitleContainingOrderBySeqDescBoards() {
		List<Board> searchList = boardRepository.findByTitleContainingOrderBySeqDesc("17");
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
		
	}
	
	/*
	@Test
	public void testFindByTitleContaining() {
		// Pageable paging = PageRequest.of(0, 5); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력
		Pageable paging = PageRequest.of(0, 5, Sort.Direction.DESC, "seq"); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력, 정렬은 seq desc
		List<Board> searchList = boardRepository.findByTitleContaining("제목", paging);
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
	*/
	
	@Test
	public void testFindByTitleContaining2() {
		
		Pageable paging = PageRequest.of(39, 5, Sort.Direction.DESC, "seq"); // 1페이지(0페이지 부터 시작) , 5개 리스트 출력, 정렬은 seq desc
		Page<Board> pageInfo = boardRepository.findByTitleContaining("제목", paging);
		
		System.out.println("현재페이지 번호 =>"+ pageInfo.getNumber()); // 0부터 시작함
		System.out.println("페이지 당 최대 게시물 갯수(상수값)=>" + pageInfo.getSize());
		System.out.println("현재 페이지 게시물 개수=>" + pageInfo.getNumberOfElements());
		System.out.println("페이지 전체 갯수=>" + pageInfo.getTotalPages());
		System.out.println("게시물 전체 갯수=>" + pageInfo.getTotalElements());
		
		
		if(pageInfo.previousPageable().isUnpaged()) {
			System.out.println("이전 페이지 객체=> 없다");
		}else {
			System.out.println("이전 페이지 객체=>" + pageInfo.previousPageable());
		}
		
		if(pageInfo.nextPageable().isUnpaged()){
			System.out.println("다음 페이지 객체 => 없다");
		}else {
			System.out.println("다음 페이지 객체 =>" + pageInfo.nextPageable());
		}
		
		System.out.println("이전 페이지 존재 여부 =>" + pageInfo.hasPrevious()); 
		System.out.println("다음 페이지 존재 여부=>" + pageInfo.hasNext());
		System.out.println("마지막 페이지 여부=>" + pageInfo.isLast());
		System.out.println("결과 존재여부=>" + pageInfo.hasContent());
		System.out.println("Sort 객체 정보=>" + pageInfo.getSort());
		
		/*
		 * 총 39( 40페이지 있음), 마지막 페이지 테스트
		 
		현재페이지 번호 =>39
		페이지 당 최대 게시물 갯수(상수값)=>5
		현재 페이지 게시물 개수=>5
		페이지 전체 갯수=>40
		게시물 전체 갯수=>200
		이전 페이지 객체=>Page request [number: 38, size 5, sort: seq: DESC]
		다음 페이지 객체 => 없다
		이전 페이지 존재 여부 =>true
		다음 페이지 존재 여부=>false
		마지막 페이지 여부=>true
		결과 존재여부=>true
		Sort 객체 정보=>seq: DESC
		 */
		
		List<Board> searchList = pageInfo.getContent(); //현재 페이지 결과 목록
		for(Board board : searchList) {
			System.out.println(board.toString());
		}
	}
}

