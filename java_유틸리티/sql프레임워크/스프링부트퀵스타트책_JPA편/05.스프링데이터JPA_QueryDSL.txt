QueryDSL
	
	QueryDSL은 정적 타입(Type-Safe)을 이용해 JPQL을 자바 코드로 생성해주는 오픈소스 라이브러리로, 
	컴파일 시점에 문법 오류를 잡고, 동적 쿼리나 복잡한 조인 등을 훨씬 유연하고 직관적으로 작성할 수 있게 도와주는 
	스프링 데이터 JPA의 보완재 라이브러리입니다. 
	
	단순 CRUD는 스프링 데이터 JPA 쿼리 메서드를 쓰고, 
	복잡한 쿼리는 QueryDSL을 활용하여 개발 생산성과 쿼리 안정성을 높이는 데 사용됩니다. 
	
	Spring Data JPA와 QueryDSL 의 조합은 복잡한 동적 쿼리를 안전하게 처리하기 위한 표준 기술 스택으로 자리 잡고 있습니다.
	
	
	Spring Data JPA는 크게 2가지 방법으로 QueryDSL을 지원한다.
	
	1. org.springframework.data.querydsl.QuerydslPredicateExecutor (인터페이스)
	2. org.springframework.data.jpa.repository.support.QuerydslRepositorySuppor (추상클래스)
	
	책 예제는 QuerydslPredicateExecutor 를 활용한 예제입니다
	
------------------- pom.xml 

	<!-- query DSL-->
	<dependency>
		<groupId>com.querydsl</groupId>
		<artifactId>querydsl-apt</artifactId>
		<version>${querydsl.version}</version>
		<classifier>jakarta</classifier> <!-- 이게 중요 -->
		<scope>provided</scope>
	</dependency>

	<dependency>
		<groupId>com.querydsl</groupId>
		<artifactId>querydsl-jpa</artifactId>
		<version>${querydsl.version}</version>
		<classifier>jakarta</classifier> <!-- 이게 중요 -->
	</dependency>
	
	
	<!-- 플러그인 추가 -->
	
	<plugin>
		<groupId>com.mysema.maven</groupId>
		<artifactId>apt-maven-plugin</artifactId>
		<version>1.1.3</version>
		<executions>
		    <execution>
			<goals>
			    <goal>process</goal>
			</goals>
			<configuration>
			    <outputDirectory>target/generated-sources/annotations</outputDirectory>
			    <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
			</configuration>
		    </execution>
		</executions>
	</plugin>
	
------------------- application.properties

# DataSource Setting
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=

# JPA Setting
spring.jpa.hibernate.ddl-auto=update #create
spring.jpa.generate-ddl=false
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.format_sql=true

# Logging Setting
logging.level.org.hibernate=info

-------------------Board.java

package com.solgae.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Entity
public class Board {

	@Id
	@GeneratedValue
	private Long seq;
	private String title;
	private String writer;
	private String content;
	private LocalDateTime createDate;
	private Long cnt;
}

------------------- (자동생성됨)target/generated-sources/annotations/../QBoard.java

package com.solgae.domain;

import static com.querydsl.core.types.PathMetadataFactory.*;

import com.querydsl.core.types.dsl.*;

import com.querydsl.core.types.PathMetadata;
import javax.annotation.processing.Generated;
import com.querydsl.core.types.Path;


/**
 * QBoard is a Querydsl query type for Board
 */
@Generated("com.querydsl.codegen.DefaultEntitySerializer")
public class QBoard extends EntityPathBase<Board> {

    private static final long serialVersionUID = -669895422L;

    public static final QBoard board = new QBoard("board");

    public final NumberPath<Long> cnt = createNumber("cnt", Long.class);

    public final StringPath content = createString("content");

    public final DateTimePath<java.time.LocalDateTime> createDate = createDateTime("createDate", java.time.LocalDateTime.class);

    public final NumberPath<Long> seq = createNumber("seq", Long.class);

    public final StringPath title = createString("title");

    public final StringPath writer = createString("writer");

    public QBoard(String variable) {
        super(Board.class, forVariable(variable));
    }

    public QBoard(Path<? extends Board> path) {
        super(path.getType(), path.getMetadata());
    }

    public QBoard(PathMetadata metadata) {
        super(Board.class, metadata);
    }

}

------------------- DynamicBoardRepositary.java

package com.solgae.persistence;

import org.springframework.data.querydsl.QuerydslPredicateExecutor; //<= 추가
import org.springframework.data.repository.CrudRepository;

import com.solgae.domain.Board;

public interface DynamicBoardRepositary extends CrudRepository<Board, Long>, QuerydslPredicateExecutor<Board> {

}
------------------- 테스트.java

package com.solgae.repositary;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import com.querydsl.core.BooleanBuilder;
import com.solgae.domain.Board;
import com.solgae.domain.QBoard;
import com.solgae.persistence.DynamicBoardRepositary;

@SpringBootTest
public class DynamicQueryDslTest {

	@Autowired
	private DynamicBoardRepositary boardRepositary;
	
	/*
	@BeforeEach
	public void dataPrepare() {
		for(int i=1; i <= 200; i++) {
			Board vo = new Board();
			vo.setTitle("테스트 제목" + i);
			vo.setWriter("테스터");
			vo.setContent("글내용: + "+i);
			vo.setCreateDate(LocalDateTime.now());
			vo.setCnt(0L);
			
			boardRepository.save(vo);
			
		}
	}
	*/
	
	@Test
	public void testDynamicQuery1(){
		String searchCondition ="CONTENT";
		String searchKeyword = "글내용: + 10";
		
		BooleanBuilder builder = new BooleanBuilder(); //<= Pradicate 인터페이스를 구현한 빌더
		
		QBoard qBoard = QBoard.board; //<==== QueryDSL이 만든 Q클래스
		
		if("TITLE".equals(searchCondition)) {
			builder.and(qBoard.title.like("%" + searchKeyword + "%"));
		}else if("CONTENT".equals(searchCondition)) {
			builder.and(qBoard.content.like("%" + searchKeyword + "%"));
		}
		
		Pageable paging = PageRequest.of(0, 5); 
		Page<Board> boardList = boardRepositary.findAll(builder, paging);
		
		for(Board board : boardList) {
			System.out.println("--->"+ board.toString());
		}
	}
}

-------------------QuerydslPredicateExecutor 인터페이스 기본 메서드
 	
	findAll(Predicate... predicates): 조건에 맞는 모든 엔티티 목록 반환.
	findAll(Predicate predicate, Sort sort): 정렬 조건을 포함한 목록 반환.
	findAll(Predicate predicate, Pageable pageable): 페이징 및 정렬 조건을 포함한 목록 반환.
	findOne(Predicate predicate): 조건에 맞는 첫 번째 엔티티를 Optional로 반환.
	count(Predicate predicate): 조건에 맞는 엔티티의 개수 반환.
	exists(Predicate predicate): 조건에 맞는 엔티티가 존재하는지 여부 반환. 

Predicate (인터페이스) 구현 클래스
	com.querydsl.core.types.Predicate 
		- com.querydsl.core.BooleanBuilder;
	
QuerydslPredicateExecutor 장단점
	장점: Predicate만으로 동적 쿼리를 쉽게 작성하고, 페이징/정렬을 스프링 데이터 JPA가 처리해 줌.
	단점: 조인(JOIN) 쿼리를 직접 작성하기 어려워 실무의 복잡한 쿼리에는 부적합할 수 있음. 

