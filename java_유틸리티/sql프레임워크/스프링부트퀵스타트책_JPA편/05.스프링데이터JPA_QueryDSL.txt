QueryDSL
	
	스프링 JPA QueryDSL은 정적 타입(Type-Safe)을 이용해 JPQL을 자바 코드로 생성해주는 오픈소스 라이브러리로, 
	컴파일 시점에 문법 오류를 잡고, 동적 쿼리나 복잡한 조인 등을 훨씬 유연하고 직관적으로 작성할 수 있게 도와주는 
	스프링 데이터 JPA의 보완재 라이브러리입니다. 
	
	단순 CRUD는 스프링 데이터 JPA 쿼리 메서드를 쓰고, 
	복잡한 쿼리는 QueryDSL을 활용하여 개발 생산성과 쿼리 안정성을 높이는 데 사용됩니다. 
	
	Spring Data JPA와 QueryDSL 의 조합은 복잡한 동적 쿼리를 안전하게 처리하기 위한 표준 기술 스택으로 자리 잡고 있습니다.
	
------------------- pom.xml 

	<!-- query DSL-->
	<dependency>
		<groupId>com.querydsl</groupId>
		<artifactId>querydsl-apt</artifactId>
		<version>${querydsl.version}</version>
		<classifier>jakarta</classifier> <!-- 이게 중요 -->
		<scope>provided</scope>
	</dependency>

	<dependency>
		<groupId>com.querydsl</groupId>
		<artifactId>querydsl-jpa</artifactId>
		<version>${querydsl.version}</version>
		<classifier>jakarta</classifier> <!-- 이게 중요 -->
	</dependency>
	
	
	<!-- 플러그인 추가 -->
	
	<plugin>
		<groupId>com.mysema.maven</groupId>
		<artifactId>apt-maven-plugin</artifactId>
		<version>1.1.3</version>
		<executions>
		    <execution>
			<goals>
			    <goal>process</goal>
			</goals>
			<configuration>
			    <outputDirectory>target/generated-sources/annotations</outputDirectory>
			    <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
			</configuration>
		    </execution>
		</executions>
	</plugin>
	
------------------- application.properties

# DataSource Setting
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa
spring.datasource.password=

# JPA Setting
spring.jpa.hibernate.ddl-auto=update #create
spring.jpa.generate-ddl=false
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.properties.hibernate.format_sql=true

# Logging Setting
logging.level.org.hibernate=info

-------------------Board.java

package com.solgae.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Entity
public class Board {

	@Id
	@GeneratedValue
	private Long seq;
	private String title;
	private String writer;
	private String content;
	private LocalDateTime createDate;
	private Long cnt;
}

------------------- (자동생성됨)target/generated-sources/annotations/../QBoard.java

package com.solgae.domain;

import static com.querydsl.core.types.PathMetadataFactory.*;

import com.querydsl.core.types.dsl.*;

import com.querydsl.core.types.PathMetadata;
import javax.annotation.processing.Generated;
import com.querydsl.core.types.Path;


/**
 * QBoard is a Querydsl query type for Board
 */
@Generated("com.querydsl.codegen.DefaultEntitySerializer")
public class QBoard extends EntityPathBase<Board> {

    private static final long serialVersionUID = -669895422L;

    public static final QBoard board = new QBoard("board");

    public final NumberPath<Long> cnt = createNumber("cnt", Long.class);

    public final StringPath content = createString("content");

    public final DateTimePath<java.time.LocalDateTime> createDate = createDateTime("createDate", java.time.LocalDateTime.class);

    public final NumberPath<Long> seq = createNumber("seq", Long.class);

    public final StringPath title = createString("title");

    public final StringPath writer = createString("writer");

    public QBoard(String variable) {
        super(Board.class, forVariable(variable));
    }

    public QBoard(Path<? extends Board> path) {
        super(path.getType(), path.getMetadata());
    }

    public QBoard(PathMetadata metadata) {
        super(Board.class, metadata);
    }

}

------------------- DynamicBoardRepositary.java

package com.solgae.persistence;

import org.springframework.data.querydsl.QuerydslPredicateExecutor;
import org.springframework.data.repository.CrudRepository;

import com.solgae.domain.Board;

public interface DynamicBoardRepositary extends CrudRepository<Board, Long>, QuerydslPredicateExecutor<Board> {

}
------------------- 테스트.java

package com.solgae.repositary;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import com.querydsl.core.BooleanBuilder;
import com.solgae.domain.Board;
import com.solgae.domain.QBoard;
import com.solgae.persistence.DynamicBoardRepositary;

@SpringBootTest
public class DynamicQueryDslTest {

	@Autowired
	private DynamicBoardRepositary boardRepositary;
	
	/*
	@BeforeEach
	public void dataPrepare() {
		for(int i=1; i <= 200; i++) {
			Board vo = new Board();
			vo.setTitle("테스트 제목" + i);
			vo.setWriter("테스터");
			vo.setContent("글내용: + "+i);
			vo.setCreateDate(LocalDateTime.now());
			vo.setCnt(0L);
			
			boardRepository.save(vo);
			
		}
	}
	*/
	
	@Test
	public void testDynamicQuery1(){
		String searchCondition ="CONTENT";
		String searchKeyword = "글내용: + 10";
		
		BooleanBuilder builder = new BooleanBuilder();
		
		QBoard qBoard = QBoard.board; // <==== QueryDSL이 만든 Q클래스
		
		if("TITLE".equals(searchCondition)) {
			builder.and(qBoard.title.like("%" + searchKeyword + "%"));
		}else if("CONTENT".equals(searchCondition)) {
			builder.and(qBoard.content.like("%" + searchKeyword + "%"));
		}
		
		Pageable paging = PageRequest.of(0, 5); 
		Page<Board> boardList = boardRepositary.findAll(builder, paging);
		
		for(Board board : boardList) {
			System.out.println("--->"+ board.toString());
		}
	}
}

-------------------
QueryDSL의 기본 메소드는 조회, 조건, 정렬, 페이징, 집계 함수 등을 메서드 체인 방식으로 제공한다.
JPQL보다 훨씬 유연하고 컴파일 시점에서 오류를 잡을 수 있어 편리합니다. 

	JPAQueryFactory queryFactory = new JPAQueryFactory(entityManager);

	// QMember.member는 Q클래스 인스턴스
	QMember member = QMember.member;
	QTeam team = QTeam.team;

	List<Member> members = queryFactory
	    .selectFrom(member) // SELECT * FROM Member
	    .where(member.age.gt(20)) // WHERE age > 20
	    .leftJoin(member.team, team) // LEFT JOIN Team team ON member.team_id = team.id
	    .where(team.name.eq("개발팀")) // AND team.name = '개발팀'
	    .orderBy(member.username.desc()) // ORDER BY username DESC
	    .fetch(); // List<Member> 반환
		

1. 기본 구조 (QueryFactory)
	JPAQueryFactory queryFactory;: JPAQueryFactory 객체를 생성하여 사용합니다.
	
	select(), from(), where()
	selectFrom(QEntity entity): 엔티티를 선택하고 FROM 절을 설정합니다 (예: selectFrom(member))
	
2. 검색 조건 (where절)
	메서드 체인이나 콤마(,)로 연결하며, 다양한 비교 연산자를 제공합니다. 
	eq(): 같다 (equals)
	ne(): 같지 않다 (not equals)
	in(): 포함 (in)
	notIn(): 미포함 (not in)
	go() / gt() / ge(): 크다 / 크거나 같다 (greater than / greater than or equal)
	lo() / lt() / le(): 작다 / 작거나 같다 (less than / less than or equal)
	isNull() / isNotNull(): null 여부
	like(): 패턴 매칭 (%, _ 사용)
	contains(): 부분 문자열 포함
	between(): 범위 (between A and B)
	and(), or(): 조건 결합
	
3. 조회 결과 처리 (결과 셋)
	fetch(): 결과 리스트 반환 (List).
	fetchOne(): 결과가 1개일 때 단일 객체 반환.
	fetchFirst(): 첫 번째 결과만 반환.
	fetchCount(): count() 쿼리로 변환하여 개수 반환.
	fetchResults(): 페이징 정보와 함께 결과 리스트 반환 (QueryResults) 
	
4. 정렬 (OrderBy)
	orderBy(entity.field.asc()): 오름차순 (ascending).
	orderBy(entity.field.desc()): 내림차순 (descending).
	orderBy(entity.field.asc(), entity.otherField.desc()): 여러 조건 정렬.
	
5. 집계 및 그룹화
	count(), sum(), avg(), min(), max(): JPQL 집합 함수 사용 가능.
	groupBy(entity.field): 그룹화.
	
	