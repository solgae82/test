	문서 
		1.에러체크_Validator_BindingResult.txt 
		2.에러체크_Validator_BindingResult.txt 
	
	에 연결된 문서 입니다.

	컨트롤 메소드에서 코드로 직접 validator를 생성 제어가 아닌, 
	모델에 @Valid 를 이용한 유효성 검증 방식이다

	@Valid를 사용하기 위해선, JSR 303 API를 설치해야 한다.

---------

pom.xml
	<!-- JSR 303 API -->
	<dependency>
		<groupId>javax.validation</groupId>
		<artifactId>validation-api</artifactId>
		<version>1.0.0.GA</version>
	</dependency>

error.properties
		
		required.uid=아이디는 필수입니다. # <= 요게 순위가 높으므로 이 메시지 선택
		required=필수입니다.

MemberRegistValidator.java

	public void validate(Object target, Errors errors) {
		ValidationUtils.rejectIfEmpty(errors, "uid", "required","아이디 없시유");
	}

TestController.java
	: UserVO 모델에 @Valid 어노테이션을 붙여 준다

	@RequestMapping("/testLoginProc.do")
	public String testLoginProc(@Valid @ModelAttribute UserVO user ,
			BindingResult bindResult , Model model ,Locale locale) throws Exception{
		
		//아무런 유효성 검증 코드도 없다.. UserVO 앞에 @Valid 뿐..
		
		return "loginForm";
	}

	@InitBinder
	protected void initBainder(WebDataBinder binder) {
		binder.setValidator(new MemberRegistValidator()); //여기서 직접 validator를 등록해준다
	}

loginForm.jsp
	<spring:hasBindErrors name="userVO" />
	<form  id="f" name="f" action="<c:url value="/testLoginProc.do"/>" method="get">

		<!-- 에러 출력 포인트-->
		<input type="text" id="uid" name="uid" value=" /> <br />
		<form:errors path="userVO.uid" /><br />
		<!-- 에러 출력 포인트 -->		
		....
		
		<button type="submit" >전송</button>
	</form>


	입력 없이 전송 누르면  아래처럼 출력될 것이다

	출력 : 
		<input type="text" id="uid" name="uid" value=" /> <br />
		<span id="uid.errors">아이디는 필수입니다</span><br />

---------기타

	Validator를 컨트롤 설정이 아닌 글로벌로 설정해 사용가능(별로 사용 가치는 없지만..)

		<annotation-driven validator="validator" />
		<bean id="validator" class="com.solgae.test.MemberRegistValidator" />

	이렇게 글로벌로 등록해 두면 @Valid 가 붙은 모델이 있을 경우 글로벌로 설정한 MemberRegistValidator
	가 작동한다.
	하지만 MemberRegistValidator.supports() 에서 검증 지원 객체가 아니면 (false)  
	검증 하지 않는다(이 정도가 아니라 아마도 에러를 뿜을 것이다)(그래서 쓸모가 없다는 거)

	글로벌 Validator가 아닌, 직접 설정하고 싶으면, 위의 예제처럼 컨트롤러에서 직접 
		@InitBinder
		protected void initBainder(WebDataBinder binder) {
			binder.setValidator(new MemberRegistValidator());
		}
	설정 해주면 설정된 validator가 작동한다.

	글로벌 validator + 추가 validator를 사용하고 싶으면 addValidator() 메소드를 사용하면 된다.
		
		binder.addValidator(new MemberRegistValidator());

	글로벌 validator를 지정하지 않았다면 
	JSR 303 애노테이션을 지원하는 Validator 클래스가 글로벌 validator로 등록된다.

---------//기타 2

	에러:  java.lang.IllegalStateException: Invalid target for Validator

	Contrller 메소드에서 initBainder 방식으로 설정하면

	메소드 파라미터의 @Valid 가 붙은 커맨드 객체만 검사하는게 아니라,
	아래처럼 모델에 담을 때 인수에도 검사하더라..
	
	아마도 @ModelAttribute("searchVO")TestVO searchVO 가 붙은 객체와 같은 객체를(또는 부모형 객체 포함)
	어떤 메소드의 인수로 넣는다면 그것마저도 검사해 버린다.
	
	model.addAttribute("testVO" , testService.selectBbs(searchVO)); //TestVO형 셋팅

	예제)
	public String testView2(@ModelAttribute("searchVO")TestVO searchVO , Model model) throws Exception{
		
		//아래는 CateVO 형을 셋 하므로 검사대상 제외
		model.addAttribute("cateList", testService.selectCateList("category"));
		
		/**
		TestVO 타입을 반환하는데, 상위 부모 버전인 Test 반환으로 했더니 이것도 검사 대상
		근데 TestVO 와는 다르기 때문에 설정한 MemberRegistValidator.supports에서
		false 를 반환하며, 프로그램 에러로 진행 불가.
		TestVO 타입으로 반환 변경 했더니, 에러 안나고
		MemberRegistValidator.validator 메소드 진행

		*/

		//model.addAttribute("testVO" , testService.selectBbs(searchVO)); 
		
		// 혹시나 해서 인수형식이 아닌 그냥 메소드만 실행했더니, 검사대상 제외.
		Test test= testService.selectBbs(searchVO);
				
		return "/test2/view2";
	}


	정확히 타입이 맞아야 한다.
	부모 타입등의 반환 후 인수 지정시 에러를 만날 가능성이 많다.
	고로 예기치 못한 에러가 발생할 수 있다....(요걸로 또 한참동안 짜증, 좌절....)
	
	initBainder 방식은 컨트롤 하기가 만만치 않다..
	걍 메소드에서 명시적으로 검사하는게 더 나을 것 같다

