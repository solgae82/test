이클립스 같은 IDE 사용하면 경고 메시지를 볼 수 없으므로 
수동 컴파일과, 컴파일시 -Xlint 를 붙여 컴파일하면 경고 메시지가 상세히 출력된다.

-------------------
JDK가 지원하는 기본(표준) 애노테이션


@Override
	상위 클래스에서 오버라이딩 했다는 것을 컴파일러에 알려준다.
	개발자가 잘못된 재선언을 할 경우 컴파일러가 알려준다
	
@Deprecated
	더 이상 사용하지 말라는 기능에 붙인다
	변수, 메소드, 클래스등에 선언하면, 호출하는 곳에서 컴파일시 경고 메시지를 보여준다
	
	class NewClass{
		int newField;
		
		@Deprecated 
		int oldFiled;
		
		int getNewField() {return newField;}
		
		@Deprecated
		int getOldField() {return oldFiled;}
	
	}

	public class Test {
		
	    //@SuppressWarnings("deprecation") //이렇게 하면 'deprecation' 경고를 억제한다.
	    public static void main(String[] args) {
				
		NewClass nc = new NewClass();
		
		// 컴파일시 경고-> warning: [deprecation] oldFiled in NewClass has been deprecated
		nc.oldFiled = 20; 
		
		// 컴파일시 경고-> warning: [deprecation] getOldField() in NewClass has been deprecated
		int old = nc.getOldField();
		
		System.out.println(old);
	    }
	}
	
	
	-Xlint 옵션으로 컴파일시 'deprecation' 경고 메시지를 출력한다 
	
@FunctionalInterface
	함수형 인터페이스를 선언할때 사용하는 애노테이션
	컴파일러가 함수형 인터페이스 여부를 확인한다.
	
	@FunctionalInterface
	interface MyFuc{
		public abstract int max(int a, int b);
	}
		
@SuppressWarnings
	경고 메시지 억제 애노테이션
	
	경고메시지 종류: @SuppressWarnings("경고메시지")
	
		deprecation : @Deprecated가 붙은 대상을 사용할 경우 발생하는 경고
		
		rawtypes : 지네릭 타입을 사용할 때 타입 매개변수를 명시하지 않고 
			원시 타입(Raw Types)을 사용할 때 발생하는 경고
			
			List rawList = new ArrayList(); // rawtypes 경고 발생
			
			
		unchecked : 
			컴파일러가 타입 검사를 할 수 없는 상황에서 발생하는 경고이다. 
			주로 타입 캐스팅이나 제네릭 타입과 관련된 작업에서 타입 안전성을 보장할 수 없을 때 발생
			
			List rawList = new ArrayList(); // rawtypes 경고 발생
			rawList.add("Hello");	// unchecked 경고발생
			rawList.add(42);	// unchecked 경고발생
		
			
		varargs : 가변인자 타입이 지네릭 타입일때 발생하는 경고
		
			void method (T... arr)
		
	사용예: 
		호출하는 메소드에 붙여 사용.		
		아래 예제는 컴파일시 경고 메시지 두개를 억제 적용했다.
		
		public class Test {
	
			@SuppressWarnings({"unchecked", "rawtypes"})
			public static void main(String[] args) {
						
				List rawList = new ArrayList(); // rawtypes 경고 발생
				rawList.add("Hello"); // unchecked 경고발생
				rawList.add(42);	 // unchecked 경고발생
					
			}
		}
	
@SafeVarargs
	메서드 가변인자의 타입이 non-reifiable 타입(지네릭)일 경우 사용하는 애노테이션.
	항상 @SuppressWarnings("varargs")와 함께 선언해서 사용한다.
	
	(T... arr) 처럼 메서드 가변인자의 타입이 non-reifiable 타입일 경우 
	해당 메서드 선언 부분과 호출하는 부분에서 'unchecked'  경고가 발생한다
	또한 추가로 선언부분에 'varargs' 경고도 발생한다
	
	'unchecked' 경고 발생 억제를 하려면,
	두 지점(선언, 호출)에 다 @SuppressWarnings("unchecked")를 선언하거나
	아니면, 선언 부분에만 @SafeVarargs 설정으로 한방에 'unchecked' 경고를 억제할 수 있다.
		
	'varargs' 경고는 선언부분에만 @SuppressWarnings("varargs") 설정하면 된다.
	
	결론은 
	메소드(T... arr) 선언시,  선언부분에만
	@SafeVarargs 와 @SuppressWarnings("varargs")를 항상 같이 사용한다
	
	
	class MyArrayList<T>{
		T[] arr;
		
		@SafeVarargs
		@SuppressWarnings("varargs")
		MyArrayList(T... arr){ //가변인자 타입이 non-reifiable
			this.arr = arr;
		}
		
		@SafeVarargs
		@SuppressWarnings("varargs")
		public static <T> MyArrayList<T> asList(T... a){ //가변인자 타입이 non-reifiable
			return new MyArrayList<>(a);
		}
		
		public String toString() {
			return Arrays.toString(arr);
		}
	}
	
	-- 사용하는 곳
	
	public static void main(String[] args) {
		MyArrayList<String> list = MyArrayList.asList("1","2","3");
		System.out.println(list);
	}
	
@Native

	자바의 @Native 어노테이션은 
	네이티브 메서드(native method)에서 참조하는 상수 필드 앞에 붙여, 
	해당 상수가 네이티브 코드에서 사용됨을 나타내는 표준 메타데이터입니다. 

	이는 자바 VM(JVM)이 설치된 
	운영체제(OS)의 네이티브 코드로 구현된 메서드와 java 상수가 연결될 때 사용된다.

	@Native 어노테이션의 특징 및 용도
	
		메타데이터: 
			@ 기호를 사용하여 주석처럼 붙이지만, 
			컴파일러나 런타임 시스템에 유용한 정보를 제공하는 메타데이터입니다.
		
		용도: 
			자바의 native 키워드와 함께 사용되며, 
			네이티브 메서드에서 사용되는 상수 값을 명시합니다.
		
		표준 어노테이션: 
			java.lang 패키지에서 제공하는 기본(표준) 어노테이션 중 하나입니다.
		
		참조: 
			네이티브 메서드는 C/C++ 등으로 작성되어 OS의 기능을 직접 호출하는 경우가 많은데, 
			이때 필요한 상수 값들을 자바 코드에서 정의하고 @Native를 붙여 연결합니다. 

	(예시)
	public class NativeExample {
	    
	    // 네이티브 메서드에서 사용할 상수 필드에 @Native 어노테이션을 붙임
	    @Native
	    public static final int NATIVE_CONSTANT = 100;

	    // 네이티브 메서드 선언 (실제 구현은 네이티브 코드에 있음)
	    public native void callNativeMethod();

	}

	위 예시에서 @Native 어노테이션은 NATIVE_CONSTANT가 네이티브 코드에서 참조될 수 있음을 알려주는 역할을 합니다. 
	
	(덧붙여): 
	JNI(Java Native Interface) 는 OS의 네이티브 메서드와 java의 'native'로 선언된 메서드를 연결하는 기술
	
	