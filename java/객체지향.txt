- 변수 종류
	- 멤버변수 : 인스턴스 변수, 클래스 변수로 나뉜다. 
		class A{
			int num; // 인스턴스 변수
			static String str; // 클래스 변수
		}

		- 인스턴스 변수 : A a = new A(); 로 객체를 만들어서 접근하는 변수		
		- 클래스 변수 : A.str 로 바로 접근 가능한 변수

	- 지역 변수 : 메소드 안에서 선언되는 변수. 메소드 영역에 한정됨.

- JVM 메모리 구조
	- Method Area : 클래스 변수, 클래스 정보등
	- Heap : 인스턴스 , 인스턴스 변수등
	- Call Stack : 메서드, 지역변수 등



- 가변인자 매개변수 
	형식 :  void test(int a, String... str){}

	- 타입 + '...' + 변수명
	- 매개변수의 맨 마지막에 정의한다
	- 인자가 없이 호출가능하고, 같은 type의 배열도 가능하다
	- 기본적으로 배열의 형식과 비슷하다

	호출 : 
		test(1 , "Hello " ,"World");
		test(1); 

- 생성자 (constructor)

	- 생성자 이름은 클래스명과 같아야 한다,.
	- 반환 타입은 없어야 한다(void도 안됨)
	- 기본생성자는 생성자가 하나도 정의되지 않았을때, 컴파일러가 자동으로 추가해준다.
	  (물론 직접 명시적으로 정의해도 된다.)
	- 생성자를 코딩하지 않았고, 클래스 접근제어자가 public 이면 'public test(){}' 형식의 생성자가 자동 추가된다.
	- 생성자에서 다른 생성자 호출시 this() 형식의 다른 생성자 호출을 한다.(반드시 첫 출에서 this() 호출을 해야한다)

- this, this()
	- new 키워드로 인스턴스를 생성하면 this 라는 키워드로 그 인스턴스를 내부적으로 참조한다
	- 모드 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다
	- this() 는 생성한 인스턴스의 생성자를 호출하는 것이다. 인스턴스의 다른 생성자를 호출할때 사용한다.
		- 생성자에서 다른 생성자를 호출할때는 반드시 첫 줄에서만 호출이 가능하다
		class A(){
			int a;
			int b;

			A(){
				this(10);
				this.b = 20;

			}
			
			A(int a){
				this.a = a;
				this.b = 30;
			}
		}

		public B(){
			public static void main(String[] args) throws Exception {
				A ins = new A();

				System.out.println(ins.a); //10
				System.out.println(ins.b); //20
			}
		}
		

- 멤버변수 초기화 방법
	1) 명시적 초기화
	2) 생성자
	3) 초기화블럭 
		- 인스턴스 초기화 블록
		- 클래스 초기화 블록

	ex) 
		class A{
			int a = 4; //명시적 초기화
			Engine en = new Engine();// 명시적 초기화
			
			static {a = 5;} // 클래스 초기화 블록

			{a = 6;} // 인스턴스 초기화 블록
			
		}

	- 멤버변수 초기화 순서
		- 클래스변수 : 기본값 -> 명시적초기화 -> 클래스 초기화 블록
		- 인스턴스변수 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블록 -> 생성자


-------------------------------------------------상속

	- 상속가능한 클래스를 부모클래스로 하고 'extends' 키워드로 상속한다
		class A{}
		class B extends A{}

	- 생성자와 초기화 블록은 상속되지 않는다. 멤버만 상속된다.
	- 자식 클래스의 멤버 갯수는 조상 클래스보다 같거나 많다.
	- 자바는 다중상속이 금지되어 있다.(한개 클래스만 상속가능)
	- 부모클래스에 final 이 붙으면, 상속할 수 없는 클래스가 된다.
	- 부모클래스 메소드에 final이 붙으면, overriding 할 수 없다.
	- 부모클래스 멤버변수에 final이 붙으면 값을 변경할 수 없는 상수가 된다.

상속 or 포함 관계
	is-a(상속) , has-a(포함) 관계로 부른다.
	- is-a (상속) 관계
		원은 점이다 : Circle is a Point (안 어울린다)
		class Circle extends Point{
			
		}
	- has-a (포함) 관계
		원은 점을 가지고 있다 : Circle has a Point (어울린다)
		class Circle{
			Point p = new Point();
		}

	인간의 언어로 해석해보면, 원은 포함관계로 묶어줘야 어울린다
	예를 들어 Shape(도형) 클래스가 있다면,
		원은 도형(Shape)이다 : Circle is a Shape (어울린다)
	이렇게 어울릴경우는 상속관계로 묶어준다.
	

- Overeloading : 부모 클래스를 상속받은 자식 클래스에서 이름이 같은 메서드를 지정하는 방법. 
	- 메서드 이름이 같아야 한다
	- 매개변수 개수 또는 타입이 달라야 한다
	- 반환 타입은 영향을 미치지 않는다.
	- 

	void test(int a , long b){}
	void test(int a , int b) {}
	int test(int a){}

- Overriding : 상속받은 클래스의 특정 메서드를 다시 재구현하는 것.
	- 메서드 이름이 같아야 한다
	- 매개변수가 같아야 한다
	- 반환타입이 같아야 한다
	- 접근제어자는 부모클래스보다 좁은 범위로 변경 할 수 없다.
		public > protected > default > private

	- 부모 클래스 메서드에 정의된 예외의 갯수 보다 많은 수의 예외를 선언할 수 없다.
	(부모 클래스 메서드 예외 갯수보다 적거나 같아야 한다)
		
		예를 들어 이런 예외 클래스의 계보가 있다면..

			Exception(root Exception)
				- e1
					- e3
						- e4
						- e5
						- e6
				- e2
					- e7
						- e9
							- e10
					- e8
			
			위와 같은 상속된 구조의 Exception 구조의 root Exception 이 처리할 수 있는 예외의 갯수는
			본인 포함해서 11개이다

			e9 Exception 이 처리할 수 있는 예외 갯수는 본인 포함해서 2개다.

			부모클래스)

				void a() throws e7 {} // 처리가능 예외(e7,e9,e10),총3개

			자식클래스)
				void a() throws e3 {} // 처리가능 예외(e3, e4, e5, e6),총 4개 (X)
				void a() throws e4 {} // 처리가능 예외(e4),총 1개 (O) , 가능

		실전 예제....................

		부모클래스)
			void a() throws IOException, SQLException{}
		자식클래스)
			void a() throws IOException{} // 가능

			void a() throws Exception{} // Exception 예외는 모든 예외를 처리 할 수 있으므로 처리 가능 갯수가 가장 많다, 불가능
			
	- 인스턴스 메서드 => static 메서드, 또는 반대설정은 할 수 없다.
	- 부모의 static 메서드를 자식에서 재정의 하는 것은 얼핏 생각하면 오버라이딩 같지만, 자식 클래스에 새로 추가되는 메소드일 뿐이다
		(static A.a(){} ,  static  B.a(){} 는 각 클래스에 정의된 클래스 메서드일 뿐이다.)

- super, super()
	- super는 자손클래스에서 부모 클래스로부터 상속받은 멤버를 참조하는 사용되는 인스턴스 참조 변수(키워드) 
		this는 자신 클래스 인스턴스 참조, super는 부모 클래스 인스턴스 참조변수

	- 당연히 static 메서드에서는 사용 불가

	- super()
		this()와 마찬가지로 생성자이다, 단 부모클래스의 생성자를 의미한다.
		객체지향은 기본적으로 자식클래스의 인스턴스를 생성하면서, 부모 부모의 부모...등 최고 조상 클래스의 생성자까지 모두 호출하는 매카니즘을 구현해야한다.
		그러므로 명시적으로 호출하던가, 호출하지 않고 기본으로 구현했다면 컴파일러가 자동으로 현 클래스의 생성자에 부모 생성자를 자동으로 붙여주는 매카니즘이 있을 것이다.
		실제로 그러하다
		아래 문장이 생성자의 모든 것에 정의되는 매카니즘을 표현한다

		"Object 클래스를 제외한 모든 클래스는 생성자 첫 줄에 this(), 또는 super()를 호출해야 한다.
		만약 정의하지 않았다면 컴파일러가 자동적으로 'super();' 를 첫줄에 추가한다"

- package 
	