제네릭 용어
	class Box<T>{}
	
	Box<T>  : 제네릭 클래스, 'T의 Box' 또는 'T Box'
	T	: 제네릭 타입변수, 타입 매개변수
	Box	: 원시 타입 (raw type)
	
	Box<String>은 컴파일 후 원시타입인 Box로 바뀐다. 즉. 제네릭 타입이 제거된다.

제네릭 사용 버전
	JDK 1.5 부터 가능
	
변수 대입
	Box<String> bx = new Box<String>();
	Box<String> bx = new Box<>(); // OK, JDK 1.7부터 생략 가능
	
기본
	지네릭 클래스 선언 : 
	class Box<T>{ // 지네릭 타입 T 선언
		ArrayList<T> list = new ArrayList<T>();
		void add(T item) {list.add(item);}
		T get(int i) {return list.get(i);}
	}
	
	
	지네릭 클래스 타입 결정
	Box<String> bx = new Box<String>();
	
	아래 처럼 변경 됨	
	class Box<String>{ // 지네릭 타입 T 선언
		ArrayList<String> list = new ArrayList<String>();
		void add(String item) {list.add(item);}
		String get(int i) {return list.get(i);}	
	}
	
	
	bx.add(new Object); //에러, String 타입만 가능
	bx.add("ABC"); //OK
	String item = bx.get(0); // ABC 반환, (String) 형변환 필요없음.
	
제네릭 제한
	: Fruit 부모클래스, 자식(Grape, Apple) 클래스가 있다고 가정
	
	1. 참조변수에 설정한 제네릭 타입변수와 대입하는 제네릭 타입변수는 같아야한다
	: <String>=<String>
	
	Box<String> bx = new Box<String>();  //OK
	Box<String> bx1 = new Box<Integer>(); //에러
	Box<Fruit> bx2 = new Box<Apple>(); //에러, 될 것 같지만 안된다. 기억해라
	
	2. 설정한 제네릭 타입과 다른 타입은 대입 불가 
	
	bx.add(new Object); //에러, String 타입만 가능
	bx.add("ABC"); //OK
	
	3.당연히 설정한 제네릭 타입 자손을 매개변수로 받을 수 있다.
	
	Box<Fruit> fruitBox = new Box<Fruit>(); 
	fruitBox.add(new Apple()); // OK, Fruit 자식형이므로.. 
	fruitBox.add(new Grape()); // OK, Fruit 자식형이므로..
	fruitBox.add(new Fruit());		
		
	4.부모-자식 관계의 제네릭 클래스끼리 대입은 가능하다
	:Box<> (부모제네릭클래스) - FruitBox<> (부모제네릭클래스)
	
	Box<Fruit> fruitBox = new FruitBox<Fruit>();
	
	5. static 멤버에 타입변수를 사용할 수 없다 
	: 인스턴스 변수를 참조할 수 없기 때문..
	
	class Box<T>{
		// static 멤버에 타입변수 T 지정 불가
		//static T item: //에러
		//static int compare(T ta, T t2){..} //에러
		
		T[] item; //OK , T타입 참조 변수는 가능
		
		T[] toArray{
			T[] arr = new T[item.length] // 에러, 제네릭 배열 생성불가
			
		}
	}
	
	: new 연산자는 컴파일 시점에 타입이 뭔지 정확히 알아야 한다. (T 사용 불가)
	instanceof 연산자도 마찬가지로 피연자로 T 사용 불가
	[참고] Collections.toArray(T[] a) 를 뜯어서 보자
	

제네릭 클래스 타입변수 범위제한
	: Fruit 부모클래스, 자식(Grape, Apple) 클래스가 있다고 가정
	: <T extends Fruit> , Fruit 포함, 상속 클래스만 타입변수로 사용 가능
	
	1. extends 키워드 
	: 클래스 ,추상클래스, 인터페이스
	
		class FruitBox<T extends Fruit>{ //Fruit클래스 포함, 자손 클래스 포함
			ArrayList<T> list = new ArrayList<T>();
		}
		
		FruitBox<Apple> appleBox = new FruitBox<Apple>(); // OK, 자식 클래스
		FruitBox<Fruit> fruitBox = new FruitBox<Fruit>(); // OK
		FruitBox<Toy> toyBox = new FruitBox<Toy>();	// 에러, Fruit 가족 클래스가 아님
	
	2. '&' 
	: 확장 클래스나, 추상클래스, 인터페이스
	: &로 연결하면 연결된 클래스 포함해서 구현, 또는 확장한 클래스(또는 인터페이스)라는 의미
		
		interface Eatable{}

		class Fruit implements Eatable{
			public String toString() {return "Fruit";}
		}
		class Apple extends Fruit{public String toString() {return "Apple";}}
		class Grape extends Fruit{public String toString() {return "Grape";}}
		class Toy{public String toString() {return "Toy";}}
		
		//Fruit클래스+Eatable 포함, 자손 클래스 포함
		class FruitBox<T extends Fruit & Eatable>{ 
			ArrayList<T> list = new ArrayList<T>();
		}
		
		FruitBox<Apple> appleBox = new FruitBox<Apple>(); // OK, 자식 클래스
		FruitBox<Fruit> fruitBox = new FruitBox<Fruit>(); // OK
		FruitBox<Toy> toyBox = new FruitBox<Toy>();	// 에러, Fruit 가족 클래스가 아님

메소드에 제네릭 매개변수 사용시 제네릭타입변수 제한
	/*
	 * 메소드 제네릭 매개변수 설정 시 사용되는 제네릭 타입변수 제한
	 * 
	 * ? : 와일드 카드, '?' 만으로는 Object 타입과 다를게 없으므로 아래처럼 제한을 이용한다.
	 * 
	 * <? extends T> 와일드 카드의 상한 제한,  T와 그 자손들만 가능
	 * <? super T> 와일드 카드의 하한 제한, T와 그 조상들만 가능
	 * <?> 제한없음. 모든 타입 가능. <? extends Object>와 동일
	 */
	 class Juice{
		static void makeJuice1(FruitBox<Fruit> b) {
			// Fruit 형만 가능
		}
		
		static void makeJuice2(FruitBox<? extends Fruit> b) {
			// Fruit 형과 그 자식형만 사용 가능
		}
		
		static void makeJuice2(FruitBox<? super Apple> b) {
			// Fruit 형과 그 조상형만 사용 가능
		}
	}
	--------
	Juice.makeJuice1(new FruitBox<Fruit>());
	Juice.makeJuice1(new FruitBox<Apple>()); // 에러,  FruitBox<Fruit>만 가능
	
	Juice.makeJuice2(new FruitBox<Fruit>());
	Juice.makeJuice2(new FruitBox<Apple>()); //OK, Fruit 자식형 가능
	
	Juice.makeJuice3(new FruitBox<Fruit>()); // OK, 조상
	Juice.makeJuice3(new FruitBox<Apple>()); // Ok, Apple
	Juice.makeJuice3(new FruitBox<Grape>()); //에러 ,Apple 아니고 , 조상도 아님
	
	