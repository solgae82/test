

제네릭 타입의 형변환
	interface Eatable{}
	class Fruit implements Eatable{
		public String toString() {return "Fruit";}
	}
	class Apple extends Fruit{public String toString() {return "Apple";}}
	class Grape extends Fruit{public String toString() {return "Grape";}}

	class Toy{public String toString() {return "Toy";}}

	class FruitBox<T extends Fruit & Eatable> extends Box<T>{}
	class Box<T>{}

	class  Test<T>{
	private static final Test<?> EMPTY   = new Test<>();
		public static<T> Test<T> empty() {
			Test<T> t = (Test<T>) EMPTY;
			return t;
		}
	}

	//-------------------// 기본테스트 

	Box box = null;
	Box<Object> objBox = null;

	box = (Box)objBox; //OK, 원시타입 경고 발생
	objBox = (Box<Object>) box; //OK type safety 경고 발생

	//Box<Object> objBox2  = new Box<String>(); //에러, 형변환 불가능

	FruitBox<? extends Fruit> b1 = new FruitBox<Fruit>();// OK
	FruitBox<? extends Fruit> b2 = new FruitBox<Apple>();// OK
	FruitBox<? extends Fruit> b3 = new FruitBox<Grape>();// OK

	//역으로 대입도 가능하다
	FruitBox<? extends Fruit> b4  = null;
	FruitBox<Apple> appleBox = (FruitBox<Apple>)box; // OK type safety 경고 발생


	//-------------------//  Test<T> 구현 분석
	/*
	<?> 는 <? extends Object> 라는 뜻. 그러므로 대입하는 new <> 는 <Object> 이다
	아래는 같은 의미

	*/

	Test<?> empty1 = new Test<>(); //OK,  Test<Object> empty1 = new Test<>Object(); 라는 의미
	Test<? extends Object> empty2 = new Test<>(); //OK, Test<Object> empty2 = new Test<>Object(); 라는 의미
	Test<? extends Object> empty3 = new Test<Object>(); //OK, Test<Object> empty3 = new Test<>Object(); 라는 의미


	//Test<?> bank1 = new Test<?>(); // 에러 , 미확인 타입 객체 생성불가
	Test<?> bank2 = new Test<Object>(); //OK , Test<Object> bank2 = new Test<Object>(); 라는 의미.
	Test<?> bank3 = new Test<>();	// OK , Test<Object> bank3 = new Test<Object>() 라는 의미.
	/**
	* 결론은
	* Test<?> empty1 = new Test<>(); 는
	* Test<Object> empty1 = new Test<Object>(); 라는 의미
	* 
	* Test<Object> -> Test<T> 로는 형변환 불가하지만,
	* Test<Object> -> Test<?> 로 형변환 후 -> Test<T>는 형변환 가능한다(경고 발생 하지만 ..)
	* 그래서
	* Test<?> EMPTY   = new Test<>() 로 받고 ,// Test<Object> EMPTY   = new Test<>(Object)
	* Test<T> t = (Test<T>) EMPTY; 로 반환이 가능한 empty()가 구현된다.
	*  
	*/

	//-------------------// ? 포함 다른 제네릭 타입 형변환 
	 
	FruitBox<? extends Object> objBox1 = null;
	FruitBox<? extends String> strBox1 = null;

	objBox1 = (FruitBox<? extends Object>) strBox1; //OK, 미확정 타입 형변환 경고
	strBox1 = (FruitBox<? extends String>) objBox1; //OK, 미확정 타입 형변환 경고
	 