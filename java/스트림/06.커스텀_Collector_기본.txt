커스텀 Collector 만들기

- java.util.stream.Collector 인터페이스를 구현하는 클래스를 작성한다
	
- 구현 해야할 메소드 5개
	public interface Collector<T, A, R> {
		Supplier<A> supplier(); 
		BiConsumer<A, T> accumulator();
		BinaryOperator<A> combiner();
		Function<A, R> finisher();
		Set<Characteristics> characteristics();
	}

	Supplier<A> supplier() : 작업 결과를 저장할 공간 제공
	
	BiConsumer<A, T> accumulator() : 스트림의 요소 수집할 방법 구현
	
	BinaryOperator<A> combiner() : 병렬 스트림일때 두 저장공간 병합할 방법 구현
	
	Function<A, R> finisher(); 결과를 최종적으로 변환할 방법 구현
	
	Set<Characteristics> characteristics() : Collector가 수행하는 작업 속성 힌트 JVM에게 제공
	
		- Collector.Characteristics.CONCURRENT
			: 병렬로 처리할 수 있는 작업
			
		- Collector.Characteristics.UNORDERED
			: 스트림 요소의 순서가 유지될 필요가 없는 작업
			
		- Collector.Characteristics.IDENTITY_FINISH
			: finisher() 가 항등 함수인 작업
			
	※ Characteristics 이슈는 따로 정리하기로 한다.
		
	
예제를 보며 익숙해지자

----------------------------- 예제 1

// 누적기에 Integer를 사용할 수 없다 . Integer는 immutable 이기 때문이다
// int[] 가변 객체를 이용하면 누적 계산이 가능하다

/* null + 빈 문자열은 뺀 요소 갯수를 뽑아내는 Collector 클래스 */

class customCount implements Collector<String, int[], Integer>{

	@Override
	public Supplier<int[]> supplier() {
		return ()->new int[1];// 배열 1개짜리를 만들어서 거기에 계산 누적
	}

	@Override
	public BiConsumer<int[], String> accumulator() {
		// null 과  빈 문자열 카운터에 포함 안함
		return (i,s)->{if(s !=null && !s.trim().equals("")){ i[0]++;}};
	}

	@Override
	public BinaryOperator<int[]> combiner() {
		return (i1,i2)-> {
			int[] sum= {0};
			sum[0]=i1[0] + i2[0];
			return sum;
		};
	}

	@Override
	public Function<int[], Integer> finisher() {
		return s->(Integer)s[0];
	}

	@Override
	public Set<Characteristics> characteristics() {
		return Collections.emptySet(); //JVM에게 속성 힌트 제공 안함
	}
	
}

public static void main(String[] args) {
	
	Stream<String> of = Stream.of("aa","cc","bb",null,"","  ");
	
	int count = of.collect(new customCount());
	
	System.out.println("요소 갯수: " + count + "개"); // 요소 갯수: 3개
		
}

----------------------------- 예제 2

 /* 문자열 '-' 로 이어붙이는 Collector 클래스 */
class DashConcatString implements Collector<String, StringBuffer, String>{

	@Override
	public Supplier<StringBuffer> supplier() {
		return ()-> new StringBuffer();
	}

	@Override
	public BiConsumer<StringBuffer, String> accumulator() {
		return (sb,s)->{
			if(sb.length()==0) {
				sb.append(s);
			}else {
				sb.append("-");
				sb.append(s);
			}
		};
		
	}

	@Override
	public BinaryOperator<StringBuffer> combiner() {
		return (sb1, sb2)-> sb1.append(sb2);
	}

	@Override
	public Function<StringBuffer, String> finisher() {
		return (sb)-> sb.toString();
	}

	@Override
	public Set<Characteristics> characteristics() {
		return Collections.emptySet();//JVM에게 속성 힌트 제공 안함
	}

	
}

public static void main(String[] args) {
		
	Stream<String> of = Stream.of("aa","cc","bb");
	
	String collect = of.collect(new DashConcatString());
	
	System.out.println(collect); // aa-cc-bb
}