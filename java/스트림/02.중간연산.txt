skip()
	: Stream<T> skip(long n);
	: 스트림 요소를 건너뛴다
	
	IntStream intStream = IntStream.rangeClosed(1, 10); //12345678910
	intStream.skip(3).forEach(System.out::print); // 45678910

limit()
	: Stream<T> limit(long maxSize);
	: 스트림 요소를 제한
	
	IntStream intStream2 = IntStream.rangeClosed(1, 10); //12345678910
	intStream2.limit(3).forEach(System.out::print); // 123
	
filter()
	: Stream<T> filter(Predicate<? super T> predicate);
	: 스트림 중 설정한 람다연산 -> true인 것만 필터링
	: filter()를 여러번 사용할 수 있다.
	
	IntStream intStream = IntStream.rangeClosed(1, 10); //12345678910
	//짝수만 출력	
	intStream.filter((n)->(n%2)==0).forEach(System.out::print); // 246810
	
distinct() 
	: 스트림 요소 중 중복제거
	
	IntStream intStream = IntStream.of(1,2,2,2,3,4,4); //1,2,2,2,3,4,4
	intStream.distinct().forEach(System.out::print); // 1234
	
sorted()
	: sorted()
	: Stream<T> sorted(Comparator<? super T> comparator);
	: Comparator<? super T> 를 구현한 람다를 인수로 넣는다
		int compare(T o1, T o2);
	: 스트림 요소 (내림차순, 오름차순)정렬 
	: 매우 다양한 방법이 있다. 

	Stream<String> strStream = Stream.of("dd","aaa","CC","cc","b");
	
	//오름차순 정렬
	strStream.sorted().forEach(System.out::print); //CCaaabccdd
	
	strStream.sorted(Comparator.naturalOrder())
	.forEach(System.out::print); //CCaaabccdd		
		
	strStream.sorted((s1,s2)->s1.compareTo(s2))
	.forEach(System.out::print); // CCaaabccdd
	
	strStream.sorted(String::compareTo)
	.forEach(System.out::print); // CCaaabccdd

	//내림차순
	strStream.sorted(Comparator.reverseOrder())
	.forEach(System.out::print); //ddccbaaaCC
	
	strStream.sorted(Comparator.<String>reverseOrder())
	.forEach(System.out::print); // ddccbaaaCC
	
	strStream.sorted((s1,s2)->s2.compareTo(s1))
	.forEach(System.out::print); // ddccbaaaCC

	//대소문자구분 안하고 오름차순
	strStream.sorted(String.CASE_INSENSITIVE_ORDER)
	.forEach(System.out::print); // aaabCCccdd

	//대소문자구분 안하고 내림차순
	strStream.sorted(String.CASE_INSENSITIVE_ORDER.reversed())
	.forEach(System.out::print); //ddCCccbaaa

	//문자 길이 순 정렬
	strStream.sorted(Comparator.comparing(String::length))
	.forEach(System.out::print); //bddCCccaaa

	//문자 길이 순 정렬 (no 오토박싱)
	strStream.sorted(Comparator.comparingInt(String::length))
	.forEach(System.out::print); //bddCCccaaa

	//문자 길이 역순 정렬
	strStream.sorted(Comparator.comparing(String::length).reversed())
	.forEach(System.out::print); // aaaddCCccb

	//IntStream -> Stream<Integer> -> 역순 정렬
	IntStream intStream = IntStream.of(1,2,2,2,3,4,4); //1,2,2,2,3,4,4
	intStream.distinct()
	.boxed()/*IntStream -> Stream<Integer>*/
	.sorted(Comparator.reverseOrder())
	.forEach(System.out::print); //4231
	
	: 
	reversed() 는 (Comparator)인스턴스 메서드 
	Comparator.reverseOrder() 는 클래스메서드
	Comparator.reverseOrder() 는 Comparable 구현한 객체소스의 자연순서를 역순으로 정렬
	
map
	: <R> Stream<R> map(Function<? super T, ? extends R> mapper);
	: 요소에 저장된 값 중에서 원하는 필드만 뽑아내거나 특정 형태로 변환
	: map()를 여러번 사용할 수 있다.
	
	class A{
		private String name;
		private int age;
				
		public A(String name, int age) {
			super();
			this.name = name;
			this.age = age;
		}
		
		..setter, getter

	}
	Stream<A> aStream = Stream.of(new A("원.txt",2),new A("삼각형.bak",1),new A("정사각형.hwp",3));
	Stream<String> strStream =  aStream.map(A::getName); // Stream<A> -> Stream<String>
	strStream = strStream.map(s->s.substring(s.indexOf('.')+1)); //확장자 뽑아내기(txt,bak,hwp)
	strStream = strStream.map(String::toUpperCase);	// 대문자 변환	
	strStream.forEach(s -> System.out.print(s + ",")); // TXT,BAK,HWP,

mapToInt(), mpaToLong(),mapToDouble	
	: IntStream mapToInt(ToIntFunction<? super T> mapper);
	: LongStream mapToLong(ToLongFunction<? super T> mapper);
	: DoubleStream mapToDouble(ToDoubleFunction<? super T> mapper);
	: map() 은 Stream<T> 를 반환하지만, (int,long,double) 등의 기본 숫자형일때는 
	(IntStream, LongStream , DoubleStream)으로 변환해서 사용하는게 좋다
	이들 기본형 스트림은 숫자에 더 최적화된 최종연산 메서드도 제공된다
	
	기본형 스트림에 추가된 예제로 하는 추가된 최종연산
		(IntStream 일 경우)
		int		sum()		: 스트림 모든 요소 총합
		OptionalDobule	average()	: 스트림 평균값
		OptionalInt	max()		: 스트림 요소 중 제일 큰값
		OptionalInt	min()		: 스트림 요소 중 제일 작은값
	
	(예제)
	class Student{
		String name;
		int ban;
		int totalScore;
		
		public Student(String name, int ban, int totalScore) {
			this.name = name;
			this.ban = ban;
			this.totalScore = totalScore;
		}
	
	}
	
	..
	
	Stream<Student> studentStream = Stream.of(
		 new Student("이자바.txt",3, 300),
		 new Student("소자바.txt",1, 200),
		 new Student("나자바.jpg",3, 290),
		 new Student("감자바.txt",3, 180)
		 
		 );

	IntStream tsStream = studentStream.mapToInt(Student::getTotalScore);

	//System.out.println("총합=>"+tsStream.sum()); //970
	//System.out.println("평균=>"+tsStream.average().getAsDouble()); // 242.5
	//System.out.println("최대값=>"+tsStream.max().getAsInt()); // 300
	System.out.println("최소값=>"+tsStream.min().getAsInt());  // 180
	
	---------------------
	근데 위와 같이 할때 sum(), average() 모두 호출할 순 없다.(최종연산은 한번만 호출되므로)
	그래서 summaryStaticstic() 으로 통계 요약 객체를 생성해서 사용할 수 있다
	
	IntSummaryStatistics stat=tsStream.summaryStatistics();
		 
	System.out.println("스트림갯수=>"+stat.getCount()); // 스트림갯수=>4
	System.out.println("총합=>"+stat.getSum());	//총합=>970
	System.out.println("평균=>"+stat.getAverage()); // 평균=>242.5
	System.out.println("최대값=>"+stat.getMax()); // 최대값=>300
	System.out.println("최소값=>"+stat.getMin()); // 최소값=>180

peek
	: Stream<T> peek(Consumer<? super T> action);
	: 연산사이에 처리되는 모습을 보고 싶을때 사용. 
	: filter나 map의 결과 중간 확인용으로 사용하는 메소드
	: peek()를 여러번 사용할 수 있다.
	
	Stream<String> strStream = Stream.of("dd","aa","dd","cc","bb");
		
	strStream.distinct().peek(s->System.out.println("중간확인:"+s))
	/*
	중간확인:dd
	중간확인:aa
	중간확인:cc
	중간확인:bb
	*/
	.sorted().forEach(System.out::print); // aabbccdd
		
변환 
	:기본형스트림과 Stream<T> 사이에 상호변환 가능하다
	
	//IntStream -> Stream<String>
	IntStream intStream = IntStream.of(3,7,5,2,6,5,4,1);
	Stream<String> strStream = intStream.mapToObj(n-> n+",");
	strStream.sorted().forEach(System.out::print); //1,2,3,4,5,5,6,7,

	// IntStream -> Stream<Integer>
	IntStream intStream = IntStream.of(3,7,5,2,6,5,4,1);
	Stream<Integer> iStream =  intStream.boxed();
	iStream.sorted().forEach(System.out::print); //1234567
	
	// CharSequence -> IntStream (ASCII)
	IntStream chrStream = "12345".chars(); //49,50,51,52,53 (문자->ASCII 변환.[ex: 1->49])
	//'0'아스키코드 10진수로 48
	chrStream.map(ch -> ch-'0').forEach(System.out::print); // 12345
	 
	// Stream<String> -> IntStream
	Stream<String> strStream1 = Stream.of("2","1","3","4");
	IntStream intStream1 = strStream1.mapToInt(Integer::parseInt);
	intStream1.forEach(System.out::print); // 2134
	 
	// Stream<Integer> -> IntStream
	Stream<Integer> iStream2 = Stream.of(2,1,3,4);
	IntStream intStream2 = iStream2.mapToInt(Integer::intValue);
	intStream2.sorted().forEach(System.out::print); // 1234