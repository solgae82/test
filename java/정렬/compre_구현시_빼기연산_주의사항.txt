
오름차순 구현시 1,0,-1 반환 규칙을 아래처럼 '-' 마이너스 연산으로 할때가 있다
만능 기법인 듯 보이지만, 치명적 결점이 있으니 제대로 알고 써야한다.

	Integer[] arr = {9,2,5,1,3,7,6,4,8};
			
	Arrays.sort(arr, new Comparator<Integer>() {

		@Override
		public int compare(Integer o1, Integer o2) {
			
			return o1.intValue() - o2.intValue(); // 요기 이부분
		}
		
	});

	System.out.println(Arrays.toString(arr)); //[1, 2, 3, 4, 5, 6, 7, 8, 9]

내림차순은 o1 <-> o2 순서를 바꿔주거나, 앞 연산 후 * -1을 추가해주면 역순이 된다.

그러나 이 '마이너스' 기법은 아래와 같은 결점이 있다.

	System.out.println(1 - (-2)); // 3
	System.out.println(1 - (-3)); // 3 
	..
	
양수가 나와야 num1이 큰 것을 알 수 있다.
근데 int형 최저 값을 대입하면 반대의 결과가 나온다.

	System.out.println(Integer.MAX_VALUE); // 2147483647
	System.out.println(Integer.MIN_VALUE); // -2147483648
	System.out.println(1 - (-2147483648)); // -2147483647 <= 요기!!
	
논리적으로는 1이 -2147483648 보다 크다. 그러므로 양수 2147483649를 출력해야할 것 같은데,
int형 최대 표현 숫자 2147483647을 넘어가므로 거꾸로 대입값 -1인 값으로 치환된다
즉 음수가 된다

양수가 나와야 논리적으로 맞는데, 음수가 나오니 
정렬은 (양수,0,음수) 기준으로만 정렬을 하므로 원치 않는 결과가 나오게 된다

	Integer[] arr = {9,2,5,1,3,7,6,4,8,Integer.MIN_VALUE};
		
	Arrays.sort(arr, new Comparator<Integer>() {

		@Override
		public int compare(Integer o1, Integer o2) {
			
			return o1.intValue() - o2.intValue();
		}
		
	});
	
	System.out.println(Arrays.toString(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, -2147483648]
	
그래서 저와 같은 타입 표현의 경계값까지 가는 경우를 피하기 위해 확실한 방법이 비교연산으로 
크고, 같고, 작다)를 반환해줘야한다. 이런 결점 경우까지 없애는 확실한 정석적인 방법으로 코딩하자

	Integer[] arr = {9,2,5,1,3,7,6,4,8,Integer.MIN_VALUE};
		
	Arrays.sort(arr, new Comparator<Integer>() {

		@Override
		public int compare(Integer o1, Integer o2) {
			
			//intValue() 안 써도 알아서 언박싱 한다.
			return (o1 > o2)?1:(o1 < o2)?-1:0; 
		}
		
	});
	
	System.out.println(Arrays.toString(arr)); // [-2147483648, 1, 2, 3, 4, 5, 6, 7, 8, 9]