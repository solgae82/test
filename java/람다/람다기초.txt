
아래와 같은 표현식을 람다 표현식이라고 한다.

	()->systme.out.println("Lambda");

- 람다 표현식은 익명 클래스 구현과 같다.
- 람다 표현식은 익명 클래스와 상호 호환할 수 있다
- 메소드가 하나만 있는 인터페이스 구현에 쓸 수 있다.
- 람다 표현식에 쓸 수 있는 이런 인터페이스를 (함수형 인터페이스)라 부른다.
- @FunctionalInterface 어노테이션을 인터페이스에 붙여서 더 명확히 할 수 있다.(붙이지 않아도 람다식 사용 가능)
- java 1.8 이상에서 쓴다

-----------------------------// 메소드 람다식 표현 규칙
@FunctionalInterface
interface MyClass{
	int max(int a, int b);
}

아래처럼 구현해야할 경우 가정
MyClass my = new  MyClass(){
	int max(int a, int b){
		return a + b;
	}
};

(new 없고, 구현클래스 이름 없이) 반환타입,메서드이름 삭제 , '->' 붙여서 람다식 표현
	MyClass my = (int a, int b)->{return a + b;}

반환값이 있는 경우 식으로만 표현 가능,  {} 와 return 예약어, {} 안의 ';' 삭제해야함.
	MyClass my = (int a, int b)-> a + b;

매개변수 추론이 가능하면 타입 생략 가능(매개 변수 일부분만 생략 못함, 할려면 다 해야함)
	MyClass my = (a,b)-> a + b ;	//(o)
	MyClass my = (int a, b)-> a + b; // (x)

매개변수가 하나일때는 타입과 + 괄호 생략가능
	MyClass my = new  MyClass(){
		int max(int a);
	};

	MyClass my = a -> a + 5; //(int a)->a + 5;
	MyClass my = int a -> a + 5; //(x) 타입이 있을땐 괄호 생략 불가!
	MyClass my = (int a) -> a + 5;
	
괄호{}안의 문장이 하나일때, 괄호 생략 가능(';' 포함)
	MyClass my = new  MyClass(){
		void print(int a);
	};
	
	MyClass my = (a)->{System.out.print(a);};
	MyClass my = (a)->System.out.print(a);
괄호{}안에 return문이 있을때는 괄호 생략 불가능
	MyClass my = (int a, int b)->{return a + b;};	// (o)
	MyClass my = (int a, int b)->return a + b;	// (x)


아래 예제로 감을 잡아 보자
-----------------------------//
package com.lambda.test;

@FunctionalInterface // 안 붙여도 된다.
interface MyFunction{
	void run();
}

public class LambdaTest {

	
	static void excute(MyFunction f) {
		f.run();
	}
	
	static MyFunction getMyFunction() {
		/*
		MyFunction f = () -> System.out.println("f3.run(): v1");
		return f;
		*/
		return ()->System.out.println("메소드리턴=>f3.run(): v2");
	}
	
	public static void main(String[] args) {
		
		//람다식으로 run()구현
		MyFunction f1 = () -> System.out.println("f1.run()");
		f1.run(); // f1.run()

		//익명 클래스로 runs()구현
		MyFunction f2 = new MyFunction() {
			
			@Override
			public void run() {
				System.out.println("익명클래스구현=>f2.run()");
				
			}
		};		
		f2.run(); //익명클래스구현=>f2.run()
		
		//람다식 구현체 반환
		MyFunction f3 = getMyFunction();
		f3.run(); //메소드리턴=>f3.run(): v2
		

		excute(()->System.out.println("excute->run()")); // excute->run()
	}

}

