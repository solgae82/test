여런 연산 결과 중 Optional<T>로 반환되는 값이 있다
특히 Stream 등을 사용할때 자주 마주치게 된다.
그러므로 Optional이 뭔지 알아야 결과를 사용할 수 있다

최종연산 결과를 Optional 객체에 담아서 반환하는 이유는
결과가 null 인지 매번 if 문으로 확인하는 것 보다 Optional 래퍼객체로 감싸서 
사용하면 NullpointerExcepton등에 안전한 표준 코딩이 가능해서이다.

------기본 사용법

	// of(), ofNullable() 로 생성, of() 생성시 null일때 예외발생.
	String nullStr = null;  
	//Optional<String> optval = Optional.of(str); // NullpointerException
	Optional<String> optNull = Optional.ofNullable(nullStr);
	
	//isPresent() :  null이면 false 아니면 true
	System.out.println(optNull.isPresent()); // false
	
	String strPresent = "abc";
	if(Optional.ofNullable(strPresent).isPresent()) {
		System.out.println("자료있다"); 
	}else {
		System.out.println("자료없다"); 
	}
		
	//초기화
	Optional<String> optInit = null; //이렇게 초기화 하기 보단 아래처럼 empty()로 초기화해야 여러 이점을 누릴 수 있다.
	Optional<String> optInit1 = Optional.<String>empty();
	System.out.println(optInit1.isPresent()); // false
	
	//get() : 반환 메서드
	String str = "abc";  
	Optional<String> optVal = Optional.ofNullable(str);
	System.out.println(optVal.get()); // abc , null일때는  NoSuchElementException 발생
	
	// orElse() : 반환 메서드
	System.out.println(optVal.orElse(new String("없음"))); //abc, null일때는 대체 설정객체인 "없음" 반환
		
	// orElseGet() : 반환 메서드 , Supplier 람다식 가능
	String initStr = optVal.orElseGet(String::new); // null일때 , "" 로 초기화된 String 반환
	if(initStr.equals("")) System.out.println("빈 String"); // ""일때 , 빈 String 
	System.out.println(optVal.orElseGet(()->new String("빈String"))); //abc, null일때 "빈String"
	
	// orElseThrow() : 반환 메서드
	optVal.orElseThrow(NullPointerException::new); //null일때 설정한 예외 발생
		
	//Stream 처럼 filter(), map(), flatMap()을 사용할수 있다	
	
	// 아래예제는 null 또는 ""는 에러가 발생하지 않고 -1반환. 문자면 NumberFormatException 발생
	//Integer.parseInt(null); //NumberFormatException
	//Integer.parseInt(""); //NumberFormatException
		
	String nStr = "";  	
	int result = Optional.ofNullable(nStr).filter(x->x.length() > 0)
	.map(Integer::parseInt).orElse(-1);
	System.out.println(result); // -1	
			
	//ifPresent() : 값이 있으면  Consumer<? super T> 실행, 없으면 아무일도 일어나지 않는다.
	Optional.ofNullable(null).ifPresent((s)->System.out.println("s=>"+s)); // null이면 아무일도 안 일어난다
	Optional.ofNullable("").ifPresent((s)->System.out.println("s=>"+s)); // s=>
	
--------- map() VS flatMap()
	
	Optional<String> strOpt = Optional.of("abc");
	Optional<Optional<String>> strOptStr = Optional.of(strOpt);
	
	String result1 = strOptStr.get().get();
	System.out.println(result1); // abc
	
	//String result2 = strOptStr.flatMap(s->s).get(); // abc
	Optional<String> strOpt1 = strOptStr.flatMap(s->s);
	String result2 = strOpt1.get();
	System.out.println(result2); // abc
	
	// map 반환형은 반드시 Optional<R>형 이어야한다
	// map 메소드는 자동으로 Optional<R>을 감싸 준다. 굳이 Optional.of()등을 써야할 필요가 없다.
	// 만일 Optional.of(s) 로 리턴하면 Optional 이 중첩된 결과가 반환된다.=> 이런식으로 Optional<Optional<String>>
	Optional<String> strOpt2 = strOpt.map(s->s + "-");
	System.out.println(strOpt2.get()); // abc-
	Optional<Optional<String>> strOpt3 = strOpt.map(s->Optional.of(s + "-중첩"));
	System.out.println(strOpt3.get().get()); // abc-중첩	
	
	// flatMap 반환형은 반드시 Optional<R>형 이어야한다 
	// 만약 Optional<Optional<String>> 형을 faltMap(s->s)을 사용하면 그냥 리턴만 해도  Optional<String>이 된다
	// map처럼  Optional로 한번 감싸는 가공이 없는, 그러므로  Optional<Optional<String>> 중첩을 한단계 벗긴 결과가 된다.
	Optional<String> strOpt4 = strOpt.flatMap(s->Optional.of(s));
	Optional<String> strOpt5 = strOptStr.flatMap(s->s);
	
--------- OptionalInt, OptionalLong, OptionalDouble
: 기본형 Optional 

get() 메서드명이 기본형별로 다르다
	Optional<T>	: T get()
	OptionalInt	: T getAsInt()
	OptionalLong	: T getAsLong()
	OptionalDouble	: T getAsDouble()
	
	(예제)
	OptionalInt optInt = OptionalInt.of(0); 
	OptionalInt optInt2 = OptionalInt.empty();
	
	System.out.println(optInt.isPresent()); // true
	System.out.println(optInt2.isPresent());// false
	
	System.out.println(optInt.getAsInt()); // 0
	//System.out.println(optInt2.getAsInt()); // NoSuchElementException
	
	//비교
	System.out.println(optInt.equals(optInt2)); // false
	
	//Optional<T> 에서는 null == empty() 의 결과가 나온다
	Optional<String> opt = Optional.ofNullable(null);
	Optional<String> opt2 = Optional.empty();
	System.out.println(opt.equals(opt2)); // true